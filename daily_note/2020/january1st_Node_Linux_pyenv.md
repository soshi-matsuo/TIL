## Node.js
### 組み込みAPI
fsモジュール：File Systemを扱うモジュールで、組み込みなので`npm install`は不要  
- 読み込み、書き込み、一覧取得、存在判定などの基本的な操作はカバーされている  
- 各操作について同期、非同期の2種が存在し、簡単なスクリプトなどでは前者、WebサービスなどI/O処理のレイテンシを抑えたい場合は後者と使い分ける  
- ファイル、ディレクトリ情報を扱うクラスとして`fs.Stats`, `fs.Dirent`が実装されているが、後者の方が早い
  - ディレクトリエントリ：ディレクトリ内のファイル/ディレクトリのメタ情報を持つ構造体。Direntはこれの略  
- Node.jsでは予約語`__dirname`で実行中ファイルが位置しているディレクトリ名を参照できる  

JSONオブジェクト：JSONを扱える組み込みオブジェクト  
- `JSON.stringify()`でオブジェクト→JSON文字列への変換
  - 第一引数にオブジェクト、第二引数にreplacer関数、第三引数にインデントのスペースの数を指定できる  
- `JSON.parse()`でJSON文字列→オブジェクトへの変換  
  - 第一引数にJSON文字列、第二引数にreviver関数  
  
### パッケージ管理
package.json：Node.jsのプロジェクトを管理するためにnpmが生成するファイル  
- `name`,`version`の2つのキーが必須で、これによって各プロジェクトが識別される
- 外部ライブラリはこのファイルに記述することで利用できる  
  - `npm install`でコマンドラインからインストールすると自動的に記述される  
  - 利用するライブラリの本体は、プロジェクトルート直下の`node_modules`ディレクトリに格納される  
  - ライブラリのバージョン指定はSemantic Versioning（SemVer)という業界標準に従い、  
  `"<package>: "MAJOR.MINOR.PATCH"`という構造でバージョンを表す
    - Major→後方互換性のない変更が入ったときに増加  
    - Minor→後方互換性を保って機能追加が行われたときに増加  
    - Patch→後方互換性を保ってバグ修正などが行われたときに増加
    - `~`：バージョン指定へのprefixとして使うと、Patchのバージョンアップを許容するように設定できる
    - `^`：バージョン指定へのprefixとして使うと、Minor, Patchのバージョンアップを許容するように設定できる
    
### Express
Express：Webアプリ、REST APIを作成するためのフレームワークで、主に以下の機能を提供する  
- サーバ起動：`const app = express(); app.listen(port)`で指定したポート番号でサーバをリクエスト受付状態にする  
  
- ルーティング：何らかの処理と、クライアントがアクセスするパスとを紐付けるための仕組み  
  - `app.method(path, handler)`のように、ある`path`に対して`method`リクエストを受けた時の処理を`handler`で定義することでルーティングを実装する  
  - `handler`には、第一引数にリクエストオブジェクト、第二引数にレスポンスオブジェクトを受け取るCB関数を渡す  
    - レスポンスオブジェクトの`send()`,`sendFile()`,`json()`などのメソッドで、実際にクライアントにレスポンスを返す  
  - `app.use(path, middleware)`で、あるpathへのリクエストが生じた際に、先立って共通で行う処理（ロギングなど）をmiddlewareとして登録できる  
    - `path`は省略可能で、その場合全てのリクエストに対してmiddlewareが実行される  
    - middleware自体は`req`,`res`,`next`の3つの引数を受け取るただのCB関数で、`next`にはそのmiddlewareの次に実行されるmiddlewareが入っている  
      - 自作のmiddlewareを使う際は、必ず処理の最後に`next()`を呼び出す  
      →さもなくば、次のmiddlewareが呼ばれずに処理が止まり、アプリがフリーズする  
    - `app.get(path, middleware, handler)`のように、ルーティングの際に直接middlewareを定義して、そのままリクエストの`handler`にチェインすることも可能  
  
- 環境設定：`.env`ファイルをプロジェクトルートに作成して値をセットすることで、`process.env`から設定値へアクセスできるようになる  
  
- パラメータの取得：サーバ側でクライアントからのルートパラメータ、クエリパラメータを受け取る  
  - ルートパラメータ：URLセグメントの一部のことで、ユーザのリクエストの度に値が変化する部分を指す  
    - `app.get('/test/:id/posts/:month', handler)`の様に、パスの動的に受け取りたい部分にprefixをつけることで、`req.params`を通してアクセス可能  
  - クエリパラメータ：ユーザのリクエストパスの？で区切られた部分以降のことを指す  
    - `root/this/is/path?key1=value1&key2=value2`の様に、key=valueペアを&で繋いで渡される
    - サーバ側からは`req.query`を通してアクセス可能  
    
- `body-parser`と組み合わせることでHTTPリクエストボディも扱える
  
  
## Linux
### コマンド
`find`：ファイル、ディレクトリを検索するコマンド
- `find <path> -name <file_name>`で、<path>以下のディレクトリに対して再帰的にファイル名検索を行うのが基本的な使い方
  
`printenv`：環境変数の一覧を表示する
- `set`を使うと、環境変数に加えてシェル変数も表示する
### システム
PATH：環境変数の1つで、実行可能ファイルが格納されたディレクトリ群（コマンド検索パス）を表す
- ディレクトリをPATHに追加することで、コマンドをパス指定無しで入力したときに、シェルがPATH内のディレクトリを参照して対応する実行ファイルを見つけられるようになる
  - このように、コマンド検索パスをPATHに追加することをPATHを通すと言う
  - 同名の実行ファイルが複数のPATH内ディレクトリに存在する場合、新しく追加されたディレクトリの実行ファイルが優先される
- zshなら`echo $path`でスペース区切りで表示可能  
- 恒久的にPATHを通しておくには、ログインシェルの設定ファイルでPATHにディレクトリを追加するか、`/etc`以下の`paths`,`paths.d`を使う

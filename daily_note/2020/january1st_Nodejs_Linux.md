## Node.js
### 組み込みAPI
fsモジュール：File Systemを扱うモジュールで、組み込みなので`npm install`は不要  
- 読み込み、書き込み、一覧取得、存在判定などの基本的な操作はカバーされている  
- 各操作について同期、非同期の2種が存在し、簡単なスクリプトなどでは前者、WebサービスなどI/O処理のレイテンシを抑えたい場合は後者と使い分ける  
- ファイル、ディレクトリ情報を扱うクラスとして`fs.Stats`, `fs.Dirent`が実装されているが、後者の方が早い
  - ディレクトリエントリ：ディレクトリ内のファイル/ディレクトリのメタ情報を持つ構造体。Direntはこれの略  
- Node.jsでは予約語`__dirname`で実行中ファイルが位置しているディレクトリ名を参照できる  

JSONオブジェクト：JSONを扱える組み込みオブジェクト  
- `JSON.stringify()`でオブジェクト→JSON文字列への変換
  - 第一引数にオブジェクト、第二引数にreplacer関数、第三引数にインデントのスペースの数を指定できる  
- `JSON.parse()`でJSON文字列→オブジェクトへの変換  
  - 第一引数にJSON文字列、第二引数にreviver関数  
  
### パッケージ管理
package.json：Node.jsのプロジェクトを管理するためにnpmが生成するファイル  
- `name`,`version`の2つのキーが必須で、これによって各プロジェクトが識別される
- 外部ライブラリはこのファイルに記述することで利用できる  
  - `npm install`でコマンドラインからインストールすると自動的に記述される  
  - 利用するライブラリの本体は、プロジェクトルート直下の`node_modules`ディレクトリに格納される  
  - ライブラリのバージョン指定はSemantic Versioning（SemVer)という業界標準に従い、  
  `"<package>: "MAJOR.MINOR.PATCH"`という構造でバージョンを表す
    - Major→後方互換性のない変更が入ったときに増加  
    - Minor→後方互換性を保って機能追加が行われたときに増加  
    - Patch→後方互換性を保ってバグ修正などが行われたときに増加
    - `~`：バージョン指定へのprefixとして使うと、Patchのバージョンアップを許容するように設定できる
    - `^`：バージョン指定へのprefixとして使うと、Minor, Patchのバージョンアップを許容するように設定できる
    
### Express
Express：Webアプリ、REST APIを作成するためのフレームワーク。  
`express-generator`を使うとExpressを利用したアプリの骨組みを一気に構築できる。以下はExpressの基本機能概略。  
- サーバ起動：`const app = express(); app.listen(port)`で指定したポート番号でサーバをリクエスト受付状態にする  
  
- ルーティング：何らかの処理と、クライアントがアクセスするパスとを紐付けるための仕組み  
  - `app.method(path, handler)`のように、ある`path`に対して`method`リクエストを受けた時の処理を`handler`で定義することでルーティングを実装する  
  - `handler`には、第一引数にリクエストオブジェクト、第二引数にレスポンスオブジェクトを受け取るCB関数を渡す  
    - レスポンスオブジェクトの`send()`,`sendFile()`,`json()`などのメソッドで、実際にクライアントにレスポンスを返す  
  - `app.use(path, middleware)`で、あるpathへのリクエストが生じた際に、先立って共通で行う処理（ロギングなど）をmiddlewareとして登録できる  
    - `path`は省略可能で、その場合全てのリクエストに対してmiddlewareが実行される  
    - middleware自体は`req`,`res`,`next`の3つの引数を受け取るただのCB関数で、`next`にはそのmiddlewareの次に実行されるmiddlewareが入っている  
      - 自作のmiddlewareを使う際は、必ず処理の最後に`next()`を呼び出す  
      →さもなくば、次のmiddlewareが呼ばれずに処理が止まり、アプリがフリーズする  
    - `app.get(path, middleware, handler)`のように、ルーティングの際に直接middlewareを定義して、そのままリクエストの`handler`にチェインすることも可能  
  
- 環境設定：`.env`ファイルをプロジェクトルートに作成して値をセットすることで、`process.env`から設定値へアクセスできるようになる  
  
- パラメータの取得：サーバ側でクライアントからのルートパラメータ、クエリパラメータを受け取る  
  - ルートパラメータ：URLセグメントの一部のことで、ユーザのリクエストの度に値が変化する部分を指す  
    - `app.get('/test/:id/posts/:month', handler)`の様に、パスの動的に受け取りたい部分にprefixをつけることで、`req.params`を通してアクセス可能  
  - クエリパラメータ：ユーザのリクエストパスの？で区切られた部分以降のことを指す  
    - `root/this/is/path?key1=value1&key2=value2`の様に、key=valueペアを&で繋いで渡される
    - サーバ側からは`req.query`を通してアクセス可能  
    
- `body-parser`と組み合わせることでHTTPリクエストボディも扱える
  
### mongoose    
MongoDB：ドキュメント型のNoSQLデータベースの一種で、アプリケーションで利用するデータを格納するのに利用される  
- ドキュメント型：1つのデータを1件のドキュメント（RDBでのレコード）として格納し、各ドキュメントのデータ構造が柔軟  
  - RDBと違って、あるデータに関連する全ての項目は、1つのドキュメントに集約される  
  - システムが複数コンポーネントに分割されているため、各コンポーネントを改良しやすく、スケーラビリティが高い
- JSONライクなドキュメントの集合をコレクション（RDBでのテーブル）として管理する  
- RDBのような多機能クエリを備えるが、トランザクション処理や関係演算、SQLの利用は不可能  
- レプリカによる障害耐性がある  
  
mongoose：Node.jsからMongoDBを扱うためのドライバ（インターフェース）ライブラリ  
- DB接続は`mongoose.connect(MONGO_URI, option)`で可能  
  - 通常、DBのURIは`.env`で管理する    
  
- コレクション作成の際は先立ってスキーマを定義し、そのコレクション内のドキュメントの構造を設定する  
  - mongoose.Schemaを変数に格納した後、`new Schema(<obj>)`のようにコンストラクタにオブジェクトを渡すことでスキーマ定義が完了  
  - `mongoose.model(collectionName, schema)`で、定義済みのスキーマに基づいたモデル（コレクション操作用のインターフェース？）が生成される  
  
- CRUD操作  
  - Create：モデルのコンストラクタにオブジェクトを渡すことで、インスタンスとしてドキュメントが生成され、`doc.save(callback)`で保存される    
  - Read：`model.find()`系のメソッドで実行可能で、`sort()`,`limit()`,`select()`などにチェインすることで絞り込みが可能  
    - Update, Delete操作の起点となる  
  - Update：ドキュメントを`find()`して編集した後再び`save()`するか、`model.findOneAndUpdate()`などを利用する    
  - Delete：`model.remove()`で複数一括削除が可能  
  
## Linux
### コマンド
`find`：ファイル、ディレクトリを検索する
- `find <path> -name <file_name>`で、<path>以下のディレクトリに対して再帰的にファイル名検索を行うのが基本的な使い方
  
`printenv`：環境変数の一覧を表示する
- `set`を使うと、環境変数に加えてシェル変数も表示する  
  
`awk`:テキストの検索や抽出、加工等の編集操作を行う
- `awk '<pattern> {<action>}' <input_file>`の形式で、input_fileから1行ずつレコードを読み込んで、それがpatternに一致すればaction処理を実行する、という仕組み  
  - patternの典型は`$<field> ~ /<regex>/`で、省略すれば全レコードに対してactionが行われる  
  - actionの基本はprintや四則演算などで、省略すればpattern該当のレコードがprintされる  
    - action内では自作変数も利用可能  
- awkは実行時に各レコードを自動的にフィールドに分割し、フィールド変数に格納する  
  - デフォの区切り文字はタブorスペースで、-Fオプションで任意の区切り文字を指定可能  
  - フィールド変数`$0`にはレコード全体、`$1`~`$NF`には最初から最後までのフィールドが格納されている  
  - 各レコードにおいて、組み込み変数`NR`にはそれまで読み込んだレコード数が格納されている（要はその時点での行数）  
- `END{<action>}`でレコードを全て読み込み終わった後のアクションを設定可能  
  - 通常のアクションとの組み合わせでループ処理の実装が可能  
### システム
PATH：環境変数の1つで、実行可能ファイルが格納されたディレクトリ群（コマンド検索パス）を表す
- ディレクトリをPATHに追加することで、コマンドをパス指定無しで入力したときに、シェルがPATH内のディレクトリを参照して対応する実行ファイルを見つけられるようになる
  - このように、コマンド検索パスをPATHに追加することをPATHを通すと言う
  - 同名の実行ファイルが複数のPATH内ディレクトリに存在する場合、新しく追加されたディレクトリの実行ファイルが優先される
- zshなら`echo $path`でスペース区切りで表示可能  
- 恒久的にPATHを通しておくには、ログインシェルの設定ファイルでPATHにディレクトリを追加するか、`/etc`以下の`paths`,`paths.d`を使う

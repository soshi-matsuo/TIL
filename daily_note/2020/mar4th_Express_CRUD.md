# ExpressによるCRUDなWebアプリ
## テンプレートエンジン in Express
WebアプリにおいてViewページをかんたんに実装するために使われるのがテンプレートファイルで、HTMLの構造をより簡潔に書き表すことができ、文書中にサーバから値を受け取るための変数(placeholder)を利用できる。  
  
テンプレートエンジンは、レンダリングの直前に、テンプレートファイル内の変数をサーバから受け取った値に置換して静的HTMLファイルに変換する。  
  
具体的には以下の手順でExpressから利用できる。  
- `npm install`で任意のエンジンを依存関係に追加。  
- ルーティングファイルで`app.set('view engine', <templateEngine>)`を呼ぶことで、view engineというconfig値に利用したいエンジンを設定可能。  
- テンプレートファイルが置かれるディレクトリを`views`と呼び、`app.set('views', <viewsDirsPath>)`で設定可能。  
- ルーティング関数内で`res.render(<viewPage>, <valueObj>)`を呼ぶことで、テンプレートファイルに値を渡す。  

## mysql in Express
- `npm install mysql`でMySQLのドライバをインストール。  
- MySQLを起動し、`mysql.createConnection({ host: <hostName>, user: <userName>, password: "password" })`でconnectionオブジェクトを初期化。  
- `connection.query(<query string>, <valueArr>, CB)`という構文でMySQLのクエリを実行でき、実行結果をCB関数で受け取れる。  
  - query string内で`?`(placeholder)を使うと第二引数の配列の先頭から順に値を受け取れる。  

## POSTリクエストの基本
### フォームによるPOST
HTMLの`<form action="<path>" method="POST">`を介してPOSTリクエストが実行されると、HTTPリクエストヘッダの`Content-Type`が`application/x-www-form-urlencoded`に設定される。  
  
このContent-Typeは、リクエストボディの値がURLエンコーディングされていることを表し、ボディをサーバで扱うためにはパース（デコード）する必要がある。
  
Express4.16以降では、従来`body-parser`として提供されていた上記を実現する機能がデフォルトで実装されており、ルーティングファイルで`app.use(express.urlencoded({ extended: true }))`すればリクエストボディを扱える。  
### ブラウザリロードによる意図しない再POST
前提として、**ブラウザの更新機能は直前のHTTPリクエストを再度実行する**機能である。  
なので、POSTリクエストを送信した直後に更新ボタンを押すと同じPOSTリクエストが再び実行される。  
これにより、直前にDBへの追加処理などを行っていた場合、更新するたびにデータが追加されていくような挙動になってしまう。  
  
このような挙動を防ぐために、通常はPOSTのエンドポイントの処理の最後に、クライアントへ別のページへのアクセスを要請する（リダイレクトする）。  
- リダイレクト：そのレスポンスを受け取ったクライアントに、指定したURLへのリクエストを自動的に送らせる、というようなレスポンス。  
  
これによって、**クライアントから見た直前のリクエストは、リダイレクトで指定されたページへのGETリクエストになる**ので、ReloadだけでPOSTが実行されてデータが追加されるような挙動を防ぐことが出来る。  
### 安全性と冪等性
HTTPメソッドは、その**安全性**と**冪等性**において区別される事が多い。POSTは安全でも冪等でもない。  
- 冪等性：あるリソースに対して、同じリクエストを何度実行しても同じ結果（同じリソースの状態？）が得られる、という性質。  
- 安全性：リクエストの対象にとったリソースに、そのリクエストの実行によって変化を与えないという性質。  
  
POSTでリソースの更新や削除を行うことも可能だが、PUTやDELETEと違って冪等ではないので注意が必要。  
## Webアプリにおける認証
現代のWebアプリの殆どでは、クライアントはリクエストの都度認証を行うのではなく、最初のログインリクエストでのみ認証情報をサーバに送信し、その後はセッションを介して認証状況を管理している。  
具体的には、おおまかに以下のような流れで認証情報をやり取りする。  
- 初回リクエストを受け、サーバがセッションIDを発行＆セッションデータを作成。  
- クライアントはセッションIDをCookieとして保存し、次回以降のリクエストに付与する。  
- ログインページから、クライアントが認証情報を送りログイン成功。  
- クライアントのCookie内のセッションIDと紐づくセッションデータに、「そのクライアントが認証済みである」という情報が記録される。  
- セッションが有効な間は、CookieでセッションIDをサーバに伝えるだけで、そのクライアントが認証済みだと示すことが出来る。つまり、そのセッションの間ログイン状態を維持できる。  
### Expressの認証機能
主に以下を利用して実装する。  
- Passport：ユーザーの認証を実装するためのnpmパッケージ  
- express-session：Express上でセッションを扱うためのミドルウェア  
  
セッション管理をExpressで実行するには以下の手順を踏む  
- express-session, passportをインポートし、以下の３つを`app.use()`でミドルウェアとして登録  
- `session({ secret: process.env.SESSION_SECRET, resave: true, saveUninitialized: true })`  
- `passport.initialize()`  
- `passport.session()`  

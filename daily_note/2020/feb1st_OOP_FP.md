# JavaScript
## オブジェクト指向プログラミング
### 基本的構文  
- `instanceof`演算子は、オブジェクトがあるクラス（コンストラクタ関数）のインスタンスであるかを判別する  
- `obj.hasOwnProperty(<prop>)`は、そのインスタンス自身が引数に与えられたプロパティを持っているかを判別する  
### プロトタイプ
- 全インスタンスで共通の値を持つようなプロパティは、そのクラスのprototypeプロパティにセットすることで、全てのインスタンスに対して自動的に共有される  
  - 各インスタンスに対して定義されるプロパティをownプロパティと呼ぶ  
  - クラスのprototypeに対して定義されるプロパティをprototypeプロパティと呼ぶ  
  - prototypeの値の型はオブジェクトなので、prototypeプロパティは**prototype object**と呼ばれる  
- インスタンスを初期化した時、各インスタンスには自動的にconstructorプロパティがセットされる  
  - つまり、クラスのprototype objectには、コンストラクタ関数への参照がconstructorプロパティとして定義されている  
- prototype objectに新しくオブジェクトを代入することで、複数のprototypeプロパティを一括でセットできる？  
  - 手動でprototype objectを定義するとconstructorプロパティが消えるので、明示的に追加するように注意する  
- 各インスタンスはクラス（コンストラクタ関数）のprototype objectを自身のprototypeプロパティとしてそのまま受け継ぐ  
  - prototype object自身もオブジェクトなので固有のprototype objectを持っており、それはObject.prototypeを継承したもの  
- プロトタイプチェーン：あるオブジェクトのプロパティを参照する際、そのオブジェクトのownプロパティ内に見つからなかった場合はprototype objectを遡及的に探す、という仕組み  
  - インスタンスのプロパティ→SubClassのprototype object→SuperClassのprototype object→Objectのprototype objectの順で探し、見つかったら探索をやめる  
- プロトタイプメソッド：あるオブジェクトのprototype objectに登録されるメソッドのこと  
  - SuperClassから継承したプロトタイプメソッドと同名のものを定義することで、メソッドをオーバーライトできる（プロトタイプチェーンの探索順序に基づいた仕組み）  
### その他
- Mixin：継承関係に無いクラス間で定義される共通のメソッドをまとめる仕組みで、オブジェクトを引数に取って、そのオブジェクトに対してメソッドを定義する関数  
- クロージャを使うことで、クラス（コンストラクタ関数）内に定義されたローカル変数をカプセル化して扱うことができる  

## 関数型プログラミング
### 基本原則
関数型の原則→以下の特徴により、テストしやすく小さく分割されたプログラムが出来る  
１．関数の挙動に影響を与えるのは引数だけで、関数はプログラムの状態やグローバル変数とは独立して動く（冪等性？）  
２．関数は、可能な限りプログラムの状態や、データを持つグローバルなオブジェクトを変化させない  
３．副作用の最小化  
### 用語
- 第一級関数：他の一般的なデータ型と同じように、変数に代入したり、他の関数に引数として渡したり、他の関数から返り値として返させることのできる関数（JSにおける関数は全てコレ）  
- 高階関数：引数に他の関数を受け取ったり、返り値として他の関数を返したりする関数  
- ラムダ：引数として渡されたり、返り値として返されたりする関数のこと  
#### 手続き型vs宣言型
- 関数型パラダイムは宣言型のスタイルとされる  
- 手続き型：コンピュータに対し、実行してほしい一連の手続きの詳細＆手順（How）を提供するプログラミング手法。殆どの場合、プログラムの状態の変更を伴う  
- 宣言型：コンピュータに対し、求めたい出力（What）を提供することでタスクを処理するようなプログラミング手法。SQLのように、関数を組み合わせることで求める出力の性質をコンピュータに伝えるようなイメージ  
- 手続き型プログラミングによって関数外部のデータを変更するような処理にはエラーが混入しやすい  
### コーディング方針、テクニック
- 呼び出し元オブジェクトやグローバル変数への破壊的変更をmutation、mutationの結果をside effect、side effectが存在しない関数を純粋関数と呼び、関数は純粋であるべきという原則
  - 例：配列操作と副作用  
    - `Array.splice()`は呼ばれた配列に破壊的な変更を加える  
    - `Array.slice()`は純粋関数であり、配列からの要素の除外も副作用無しで可能  
    - `Array.concat()`も純粋関数で、呼び出し元配列と引数の配列を結合した新しい配列を返す  
    - `Array.push()`は呼び出し元配列に引数の要素を直接追加する  
    - `Array.join()`は純粋関数で、配列の要素を順に連結した文字列を返す  
- コード内の依存関係を常に明示的にするために、関数が扱うデータは、常に引数として直接渡すという原則  
  - これによって、関数が他のコードと疎結合になる（関数の出力が引数以外に影響されなくなる）のでテストしやすくなる  
  - Mutableなデータを引数に受け取る際は、副作用を防ぐためにローカル変数としてコピーを作る？  
- 高階関数が利用される事が多い  
  - `Array.map(cb)`：配列を反復処理し、各要素をCB関数で処理した新しい配列を返す  
    - 副作用ナシの純粋関数  
    - 必ず呼び出し元配列と同じ要素数の配列を返す  
  - `Array.filter(cb)`：配列を反復処理し、CB関数の結果がtrueである要素からなる新しい配列を返す  
    - map()との組み合わせでも多用される  
  - `Array.reduce(cb, initialValue)`：配列を反復処理して、最終的に１つの値を返す  
    - CB関数は必須の引数としてaccumulatorとcurrentValueを取り、accumulatorには直前のイテレーションの返り値が格納される  
    - 第二引数のinitialValueは最初のイテレーションの際にaccumulatorに格納される初期値を表し、設定しなかった場合は0番目の要素がaccumulator, 1番目の要素がcurrentValueの状態で処理がスタートする  
      - initialValueのデータ型は、空オブジェクトなど、Number以外でもOK  
  - `Array.sort(cb)`：配列を、要素をUnicode文字列に直した時の数値の昇順で並び替える  
    - 純粋関数ではなく、呼び出し元の配列を直接変更する  
    - CB関数には、先頭から要素が2つずつ引数として渡され（？）、cb(a, b)の返り値が0より大きいときはb, aの順、0のときはステイ、0未満でa, bの順に並び替える  
  - `Array.every(cb)`：配列を反復処理し、全ての要素についてCB関数の返り値がtrueだった場合、trueを返す  
  - `Array.some(cb)`：配列を反復処理し、いずれかの要素についてCB関数の返り値がtrueだった場合、trueを返す  
- 関数のカリー化  
  - 関数が必要とする引数の数をarityと呼ぶが、カリー化とは、ある1つのarity=Nの関数を（機能を維持したまま）arity=1のN個の関数に変換すること  
  - 具体的には、引数を1つ受け取って「次の引数を受け取る別の関数」を返すように再構築する  
  - 関数に一度に全ての引数を渡すことができないような場合に、一部の引数を簡単に固定（部分適用）できる
  - 部分適用は`Function.bind()`でも可能

# Java
## Head First Java
### act14（シリアライゼーションとファイル入出力）
オブジェクトの保存  
- あるオブジェクトのインスタンス変数などを維持したまま、外部にファイルとして保存する方法は、シリアライズor「直接ファイルにオブジェクトの状態を書き込む」の主に2種類ある
  - 保存したオブジェクトがJVMによって使用されるかどうかが判断基準  
  
シリアライズ  
- ConnectionStreamとChainStreamを組み合わせて行われる
  - ConnectionStreamは、ファイルやネットワークに対してデータをやり取りするための通信経路を表すクラス
  - ChainStreamは、ConnectionStreamが扱えるような形式にJavaプログラム上のデータを変換する（Serialize）役割を担うクラスで、単体では使用できない
- オブジェクトがシリアライズされるときは全てのインスタンス変数がシリアライズされる
  - もしオブジェクトが、他のオブジェクトへの参照をインスタンス変数として持っていた場合、その参照されているオブジェクトも連鎖的にシリアライズされる
  - `static`変数はインスタンスではなくクラスに属するのでシリアライズされない
- 自作クラスをシリアライズ可能にしたい場合は`Serializable`インターフェースを実装する
- シリアライズ処理の結果は、DBのトランザクションのように、対象オブジェクトが正しくシリアライズされるか全くされないかのどちらかにしかならない
  - シリアライズしたいオブジェクトが`Serializable`でないオブジェクトをインスタンス変数として参照していた場合、シリアライズは失敗する
  - オブジェクトは、ネットワークの接続状態やスレッドの状態などをインスタンス変数として持つことがあるが、これらは特定の実行環境依存な情報であり、保存しても意味がないので保存できないようになっている
  - シリアライズ処理をスキップしたいインスタンス変数がある場合は`transient`修飾子をつける
    - `transient`に指定されたインスタンス変数は、デシリアライズされたときにnull, false, 0などが入る
    - オブジェクトの状態が`transient`な変数の値に依存している場合は、シリアライズ以外の手段で別個にその値を保存する必要が生じる  
  
デシリアライズ  
- シリアライズの逆のフローをたどる
- 読み込もうとしているオブジェクトのクラスが、読み込み側のプログラムの中に見つからない、ロードできない場合例外をthrowする
  - クラスごとシリアライズしないのは、オブジェクトの状態の保存や送信という目的に照らして、オーバーヘッドがデカすぎるから
  - シリアライズしたオブジェクトをネットワークで送信する際に、そのオブジェクトのクラスが存在するURLの情報を併せて送ることができ、受け取り側でクラスが見つからない場合はそのURLを使ってクラスをロードすることが可能
- 新しいオブジェクトのための領域がHeap上に確保されるが、読み込もうとしているオブジェクト自身のコンストラクタは使われない
  - シリアライズされたオブジェクトの継承ツリーを遡って、`Serializable`ではないSuperClassにたどり着くと、そこから上のクラスのコンストラクタが実行される
- オブジェクトがHeap上に生成されると、シリアライズされた情報を元にオブジェクトの状態が復元される  
  
ファイルへの書き込み  
- `java.io.File`は記録装置上のファイル名、ファイルパスを司るクラス（ファイルの内容は扱わない）
  - Fileオブジェクトを経由してWriterやStreamにファイルを渡すことで、直接Stringでファイル名を渡すよりも安全になる（パスの有効性などが確かめられる？）
- `BufferedWriter`はChainStreamの一種で、`FileWriter`などのConnectionStreamと併せて使う
  - ファイルへの書き込みを行う前にBufferを介することで、Bufferの容量がいっぱいになるor`BufferedWriter.flush()`が実行されるまで、実際の書き込みが行われなくなる
  - `BufferedWriter`を介さずにファイルへの書き込みを実行する場合、`FileWriter.write()`を実行するたびにディスクへのデータ書き込みが行われるが、この処理はボトルネックになる
    - 書き込みたい内容が確定するまでBufferにデータを持っておいて、ディスクへの書き込みは一回にまとめる方が効率が良くなる
    
ファイルからの読み込み  
- シリアライズ：デシリアライズ同様、書き込みと逆のフローをたどる
- whileループで対象ファイルから読み込むべきデータがなくなるまで`readLine()`を繰り返す、という手法が一般的  

オブジェクトの状態管理  
- シリアライズ→デシリアライズの過程で、そのオブジェクトのクラスに対して特定の種類の変更があった場合、デシリアライズは失敗する
  - ex. インスタンス変数の型変更や削除、`transient`化など
- JVMはシリアライズの際に、シリアライズ対象オブジェクトの属するクラスに対してversionIDを記録する
  - これは`serialVersionUID`と呼ばれ、クラスの構造を元に計算される
- デシリアライズの際は、オブジェクトがシリアライズされた時点のクラスIDと、デシリアライズ時点のクラスのIDを比較し、IDが一致して互換性があるとみなされるとオブジェクトの復元が行われる
  - 通常、クラスに変更を加えると自動的にIDが更新されるためデシリアライズは失敗するが、クラス内でIDを定数として明示的に宣言しておくことで、クラスの変更に伴うIDの自動更新を防ぐことが出来る
  - このようにIDを固定する場合、シリアライズされたオブジェクトとそれが属するクラスの互換性をデベロッパー自身で保つ必要があり、もしクラス構造を変更した場合、手動でクラスのIDを更新しなければならない

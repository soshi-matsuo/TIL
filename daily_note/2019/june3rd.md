# Java
## 言語仕様
**Package, Classpathについて**  
- Package：複数の関連するクラス、サブパッケージ（パッケージ内のパッケージ）、インターフェースをグルーピングしたもので、以下のメリットがある  
  - Packageを分離することで同名クラスのコンフリクトを防げる  
  - 検索性の向上  
  - アクセス修飾子で、Packageを単位としてまとめてアクセス権限制御ができる  
  - データの隠蔽  
- Packageの表現はディレクトリ構造とほぼ同じで、実際に同一パッケージに属するクラスは同じディレクトリ内に存在する必要がある。サブパッケージのディレクトリも同様に、それが属するパッケージのディレクトリの中に置かれる  
- サブパッケージは自動的にはインポートされない  
- 複数パッケージが同名クラスを持っている場合は、衝突を避けるためにクラス名まで明示的に書いてインポートする  
- FQCN：Fully Qualified Class Nameの略で、パッケージ名＋クラス名を複合した名称。これが重複しないようなネーミングを行う  
- ビルトインパッケージ：Javaの標準APIとして多数のクラスで構成されているもの。うち、`java.lang`は自動でインポートされている  
- static import：import static packageとしてパッケージをインポートすると、指定したパッケージに含まれるpublic staticなクラスのメンバーを、クラスの指定無しで呼び出すことができる  
- CLASSPATH：パッケージ内のclassファイルのフルパスは`$BASE_DIR/package/Sample.class`のように表現されるが、`$BASE_DIR`はどのようにも設定できるので、クラスを見つけるためにコンパイラとJREに`$BASE_DIR`の位置を教えておく必要がある。これを環境変数として定義するのがCLASSPATH  
  - `$ java -classpath <classpath> package.class` のようにコマンドを打つことで、動的にCLASSPATHを指定してJavaクラスファイルを実行できる  
  - CLASSPATH＝ルートパッケージが置かれるディレクトリ  
  
**オブジェクトの同一性について**  
- オブジェクトの比較：「オブジェクトが等しい」というのには、「各々が同一のメモリアドレスを参照すること（**同値**）」or「オブジェクトのプロパティの値が等しいこと（**等価**）」の二通りの意味があり、前者は`==`で判別し、後者はそのクラスの`equals`メソッドで判別する  
  - 通常、プロパティの値が同じインスタンスを複数初期化しても、各々に割り当てられるメモリのアドレス（参照）は異なり、それらを`==`比較するとfalseが返される（等価だが同値ではない）  
  - 自分でHogeクラスの定義を行い、同じプロパティのインスタンス`hoge1`,`hoge2`を初期化したとして、等価性を比較しようとして`hoge1.equals(hoge2)`を実行するとfalseを返す。これは、**Object型のデフォの`equals`メソッドが「同一オブジェクトを参照しているか否か（`==`演算子での同値比較）の演算を行う」から。自作クラスのインスタンスのプロパティ比較を行うためには、同値比較ではなく等価比較を行うように`Object#equals`をオーバーライドする必要がある**  
  
- ハッシュ値による比較：オブジェクトの等価比較の手法には、プロパティを用いて生成されるハッシュ値を用いるものも有る。ハッシュ値が異なれば異なるオブジェクトとみなすことができ、`equals`での比較に比べて判定が簡単  
  - ex. `HashMap`, `HashSet`などのクラスでは等価比較の際に「最初にオブジェクトのハッシュ値を比較→等しい場合のみ、`equals`で厳密に判定」という流れを取る  
  - `hashCode`：自作クラスのインスタンスの等価比較において（`equals`同様）オーバーライドが必要なメソッド。`Object#hashCode`はプロパティではなく、そのオブジェクトの参照(メモリアドレス)に基づいてハッシュ値を返すので、プロパティからハッシュを生成するようにオーバーライドしないと上記例のようなケースで等価だと判別されずバグの原因になる  

**プリミティブ型と参照型**  
- データ型：プログラム中で扱うデータの形式を定義したもので、Javaにおいては大別してプリミティブ型と参照型がある（Pythonは全て参照(Object)型）  
- プリミティブ型：真偽値、数値、文字を表すUnicodeから成る基本的データで、リテラル（コードに直接記述される値）で宣言できる  
- 参照型：クラス（関連する変数やメソッドをまとめたもの）を実際に扱う際には、基本的にインスタンス化してそのインスタンス用のメモリの領域を確保する必要があり、使用するためにはインスタンスが格納されるメモリアドレスを知っておく必要がある。それを参照（ポインタ）と呼び、参照の値を保持するようなデータ型を参照型と呼ぶ  
- 通常参照型は`new SomeClass()`として宣言するが、String型は例外的に文字列リテラルによって変数宣言が可能  
  - `String str1 = new String("test")`と`String str2 = "test"`でやっていることは同じ  
- nullリテラル：参照型に関連するリテラルで、その変数が何も参照していない状態を示すもの。これが入った変数からメソッドを呼ぼうとするとNullPointExeptionが生じる  
- ラッパークラス：プリミティブ型は単なる値であってオブジェクトではなく、値を操作するためのメソッドは持ち合わせていないが、そのような操作が必要な場合のために、プリミティブ型を内包してメソッドも備えたラッパークラスが標準で実装されている  
  - 値のビット・バイト数についての定数や、String・プリミティブ・ラッパークラスでの相互変換用のメソッドなどが代表的な機能  

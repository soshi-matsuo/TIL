# JavaScript
## JS Primer
### JavaScriptとは
- **ウェブブラウザ上で動く**言語
- ECMAScript：どんな実行環境でも共通のJavaScriptの動作を定義した仕様
  - 例えば、Node.js上の機能はECMAで定義されたものだが、ブラウザ上のJavaScriptとは別
  - ES6(ECMAScript2015)がでかいアプデ
- JSにおけるほぼ全てはオブジェクト（値と処理をまとめたもの）であり、プログラムの処理はオブジェクトのコミュニケーションで成り立っている
  - ECMAの仕様で定まったオブジェクト、JSやNodeなどの実行環境によって定まったオブジェクト、ユーザー定義のオブジェクトが存在する
- 実行の際はScript, Moduleの2つのモードが存在する。基本は前者で、後者はJSのプログラムをモジュール化して扱うための機能
### 変数宣言
- `const`：**値を再代入できない変数**の宣言と、初期値の定義を行う
  - 参照透過性（変数の値は最初に定義した値から変化しない）を維持する機能
  - 定数になるわけではない（もしプリミティブを代入すれば定数とみなせるが、オブジェクトを代入した場合、オブジェクトのプロパティは変更できてしまう）
- `let`：**値の再代入が可能な変数**の宣言を行う（初期値未定義でもOK）
- `var`：letとほぼ同じ機能だが、挙動に問題があるのでES6以降はletかconstで書くべき（関数スコープの項参照）
### 値の評価と表示
- JSにおける「評価」→式や変数の結果を返すこと？
- JSの実行方法
  - ブラウザのDeveloper ToolのREPL
    - 入力の評価結果は、次の行に自動で表示される
  - JSファイルを`<script>`タグでHTMLファイルから読み込みブラウザでレンダリング
    - JSファイルのコードの評価結果は勝手には表示されない
    - Console API：値を評価してコンソールへの表示を行うための機能
### データ型とリテラル
- 動的型付け言語なので変数の型は存在しないが、数値・真偽値・文字列などの値自体の型（データ型）は存在する
- プリミティブ型（基本型）
  - 真偽値、数値、文字列、undefined、null、シンボルが当てはまる（文字列もプリミティブ）
  - 一度作成したら、その値自体を変更することは出来ない（Immutable）
- オブジェクト型（複合型）
  - プリミティブ型以外のデータで、オブジェクト、配列、関数、正規表現など
  - 複数のプリミティブorオブジェクトで構成される集合
  - 作成したあとも値自体を変更可能（Mutable）
  - 参照変数を経由して扱われるので、参照型のデータとも
- `typeof`演算子でPorOを判定可能
- リテラル：記述した内容が直接そのデータ型の値になる、という構文で、一部のデータ型はこれで簡単に定義できる。以下の型にはリテラルが存在
  - プリミティブ：真偽値、文字列、数値、null
    - テンプレートリテラル（ES6以降）：バッククオートで囲んだ範囲を文字列として定義する。変数のプレースホルダを入れたり、\nを使わずに改行できる
    - null：「値がない」ことを表す値。値が未定義の変数は参照できないが、値がnullの変数は参照できるので、ランタイムエラーを避けられる
  - オブジェクト：オブジェクト、配列、正規表現
    - オブジェクトリテラル：`{}`の中にkey:valueを書くことでオブジェクトを定義＆初期化できる。オブジェクトの持つキーをプロパティと呼び、`obj.key`or`obj["key"]`で値を参照できる
      - プリミティブの値でもオブジェクトのようにプロパティアクセスが可能（ex. `str.length`）
    - 正規表現リテラル：`//`で囲んだ中に正規表現のパターンを書くことで、正規表現オブジェクトを定義できる
    
### 演算子
- 比較演算子に注意
  - `===`：厳密等価演算子。同型＆同値の場合にtrueになり、オペランドがオブジェクトの場合は参照が同じ（Heap上の同じオブジェクトを指している）ときにtrueを返す。`!==`は異型or異値の場合にtrueを返す（厳密等価の逆）
  - `==`：等価演算子。オペランドが同型の場合は厳密等価と同じ挙動になるが、型が違う場合に暗黙型変換を行ってから比較するので意図と違う挙動になりがち。基本的に使うべきではない
- 分割代入（ES6以降）：配列やオブジェクトの値を、同時に複数の変数に代入できる（Pythonのタプルアンパッキングに近い）。右辺の配列やオブジェクトの値を、左辺の配列リテラルやオブジェクトリテラルの対応する変数名に代入する
  - 配列の分割代入：`const array = [1, 2]; const [a, b] = array;`とすると、arrayの0番目、1番目の要素がそれぞれa, bに代入される。`const a = array[0]; const b = array[1];`と同じ動作
  - オブジェクトの分割代入：右辺のプロパティの値を、左辺の対応するプロパティ名を持つ変数に代入する（ex. `const {a, b} = {a : 1, b : 2}`とすると、変数a, bの値に1, 2を代入できる）
- 三項演算子：`条件式 ? Trueの時処理する式 : Falseの時処理する式;`と書くことで、条件式を評価した結果がTrueなら二項目の評価結果を、Falseなら三項目の評価結果を返す
  - 条件によって変数の初期値が変わる場合などに使われる
- 論理演算子：&&, ||は、「左辺を評価した段階でT, Fが確定した場合には右辺を評価しない」という短絡評価（ショートサーキット）を行う

### 暗黙型変換と明示的型変換
- falsyな値：false, undefined, null, 0, NaN, ""の6つの値は、`Boolean()`に渡したり、条件式に渡して暗黙型変換を行ったりするとfalseになる。これ以外は全てtrue
- 特に真偽値について、型変換で求める値を得ようとするのは正確性に欠けるので注意
- `String()`での変換はプリミティブに使うよう留めるべきで、オブジェクト型は各々固有の文字列変換方法が存在する
- `Number()`で明示的に数値型への型変換ができるが、互換性のない値を変換するとNaNが返される
- NaNは何と演算してもNaNになるので、計算過程でNaNが生じると結果は必ずNaNになる。また、NaNは自分自身と一致しないという特殊な性質がある
### 関数と宣言
- 関数を定義する手法は、**`function`キーワードによる関数宣言、`function`を使った関数式、Arrow Functionを使った関数式の3つ**
- 値を返さない関数ではreturn文の返り値を省略したり、`return;`そのものを省略したりできる。その場合はundefinedが返される
- JSでは、シグネチャ上の仮引数の個数と、実際に関数を呼び出した際に与えた引数の個数が一致していなくても関数呼び出しが実行できる
  - 渡した引数が少ない時→余った仮引数にはundefinedが代入される
    - デフォルト引数（ES6以降）：Pythonと同様の書き方で、引数が与えられなかった場合のデフォルトの値をセットできる
  - 渡した引数が多い時→溢れた引数は無視される
- 可変長引数：渡される数を限定しない引数
  - Rest Parameters（ES6以降）：残余引数とも。`function test(...args) {}`のように仮引数の前に...を付けて関数定義すると、渡された引数は`args`に配列として代入される
    - 通常の仮引数とも併用可能で、その際の残余引数は仮引数の末尾で定義しなければいけない
    - 残余引数を受け取る関数に対して、既存の配列をSpread構文（配列の前に...を付けた構文）で展開して引数として渡すことも可能
  - `argument`変数：非推奨
- 分割代入は関数の引数に対しても使える
- JSでは**関数もオブジェクトの一種で、`()`をつけると関数としての処理を呼び出し、`()`を付けない場合は他のオブジェクト型と同じようにオブジェクトとして参照できる**（変数への代入や引数として渡すことができる）
  - 関数が値として扱えることをファーストクラスファンクション（第一級関数）と呼ぶ
  - 関数定義したものを値として扱うのではなく、**最初から値として関数を定義する**方法もあり、これらは**関数式**と呼ばれる
- 関数式：関数を、値として生成している式のこと（通常の関数宣言は文）で、変数への代入や引数への値渡しの際に見られる
  - `const myFunc = function() {};`のように、無名関数を左辺の変数に代入することで、変数名をトリガーにして右辺の関数を参照できるようになる
  - Arrow Function（ES6以降）：functionキーワードを使わずに無名関数を定義して左辺に代入する
    - `const 関数名 = (引数) => {処理};`が基本形
    - 関数の仮引数が一つのときは、引数を囲む`()`を省略可能
    - 処理が1つの式である場合は、`{}`によるブロック定義とreturn文を省略できる（その式の評価結果を返り値と見なす）
    - Arrow Functionは常に匿名関数
    - `argument`変数は使用不可
    - `this`の挙動がfunctionキーワードとは別
  - 可読性的には、基本的にArrow Functionで書き、問題がある場合にのみfunctionを使うべき
- JSにはオーバーロードは存在せず、同じ名前の関数が複数存在する場合は、あとに定義されたものに上書きされる
- コールバック関数：高階関数に引数の値として渡される関数のこと
  - 毎度事前にコールバック関数を定義してそれを引数に渡すのは面倒なので、高階関数の呼び出し時に関数式を使って無名関数を定義してコールバック関数を渡すことが多い
  - ex. `const array = [1, 2, 3]; array.forEach(value => { console.log(value) });`としたときのforEachが高階関数、その引数がコールバック関数
- メソッド：オブジェクトのプロパティとして定義された関数のこと
  - ES6以降ではオブジェクトリテラルに直接`メソッド名() {処理}`と書くことでメソッドが定義できる
### 文と式
- JSの要素は文（Statement）と式（Expression）
- 式：**値を生成し、変数に代入可能なもの**を式と呼ぶ
  - 具体的にはリテラル、変数や関数の呼び出し、式＆演算子の組み合わせのこと
  - 評価すると結果の値が得られ、それが**評価値**と呼ばれる。例えば、関数式の評価値は関数オブジェクトであり、そのオブジェクトは変数に代入可能
- 文：セミコロンで区切られた、処理の１ステップを文と呼ぶ
  - ifやforなどが文の具体例で、文中には式が含まれる
  - 文は式ではないので、変数への代入は出来ない
  - ブロック`{}`で囲まれた中には複数の文を書くことが出来る。また、ブロック文の末尾は例外的にセミコロン不要
- 式文：文が書けるところにはどこでも式を書くことができ、文になった式（処理のステップとして扱われる式）はセミコロンで区切られる
- 関数宣言と関数式：前者は文で後者は式
  - 関数宣言は「ブロックで終わる文」なのでセミコロン不要
  - 関数式の代入文は、「式の評価結果を変数に代入する通常の文」なのでセミコロンが必要
### 条件分岐
- switch文の用法は限定的で、関数の引数に受け取った値に応じて、決まった返り値を返すためのパターンを実装するのに使われる（returnがbreak代わりになって記述量が減らせるから？）
### 反復処理
- ループ処理≒配列に入れた要素を処理する手段といえる。なのでfor, while, do-while以外にも、配列オブジェクト自体に反復処理用のメソッドが実装されている
  - `Array#forEach()`は、配列の要素が先頭から順にコールバック関数に渡されて処理が実行される
  - `Array#some()`は、コールバック関数が一度でもtrueを返したら反復を終了してtrueを返す
  - `Array#filter()`は、コールバック関数がtrueを返した要素のみを集めた新しい配列を生成して返す
  - `Array#reduce()`は、配列の要素を2つずつコールバック関数に適用していき、コールバック関数が最後に返した値を返り値として返す
    - `reduce()`を使った反復処理では、通常のfor文などのように変数を更新していく必要がないので参照透過性が保ちやすい
- for inは非推奨
- for of文（ES6以降）：JSでは`Symbol.iterator`メソッドを実装したオブジェクトをiterableと呼び、iterableなオブジェクトを反復処理するのがfor of文
  - Arrayもiterableオブジェクトの１つ
  - 通常のオブジェクトはiterableではないので、反復処理するためには、`Object.values()`, `Object.keys()`, `Object.entries()`などでプロパティを配列として取得しておく必要がある
  - JSではStringオブジェクト（ラッパー？）もiterableオブジェクト
- 反復処理は大別して、**for, whileなどの構文を用いるか、配列のメソッド＆コールバック関数を使うか**の2つの手段に分けられる
### オブジェクト
- プロパティ（名前（key）と値（value）のペア）の集合がオブジェクト
  - キーは文字列orSymbolで、値には任意のデータが入る
- あらゆるオブジェクトのもととなるビルトインオブジェクト（どの環境でも利用可能な組込みオブジェクト）が`Object`として存在する
- オブジェクトリテラルで作成する
  - キーは、ハイフンを含まない限り""で囲まなくてもOK
  - プロパティの値に変数名を指定すると、そのプロパティのキーは指定された変数を参照する
    - ES6以降、プロパティのキー＝プロパティの値に指定する変数の名前、な場合は`const obj = { someVar };`のように省略記法でプロパティを設定できる。この例だと、objには`someVar: someVarの値`というプロパティがセットされる
  - オブジェクトリテラルは、`new Object()`として`Object`の新しいインスタンスを生成しているのと同じ処理
- プロパティの参照にはドット記法とブラケット記法があるが、基本的には簡潔な前者を使う
  - ブラケット記法では、「書かれた任意の式（変数など）の評価結果を文字列に変換したもの」をプロパティ名として扱うので、ドット記法で書けない動的な場合などにはこちらを使うべき
  - ES6以降、オブジェクトをリテラルで生成する際にも、プロパティ名をブラケット記法で書くと、`[]`内の式の評価結果がプロパティ名になる（Computed property names）
- プロパティを完全に固定するためには、Strictモードで`Object.freeze()`に固定したいオブジェクトを渡す
- **JSでは、存在しないプロパティを参照すると例外ではなくundefinedを返す**
  - undefinedはオブジェクトではないので、それに対してプロパティを参照しようとして初めて例外が生じる
  - プロパティの存在を確かめるには`in`演算子orオブジェクトの`hasOwnProperty()`を使う
    - プロトタイプオブジェクト関係でこの2つの動作は少し異なる？
- オブジェクトを文字列化すると`toString()`が実行され、`"[object Object]"`という文字列になる
- `Object`の静的メソッド→オブジェクト型のインスタンスのメソッドとしてではなく、BIOの`Object`から直接呼び出せるメソッド
  - `Object.keys()`：引数のオブジェクトのキーを列挙した配列を返す
  - `Object.values()`：引数のオブジェクトの値を列挙した〜
  - `Object.entries()`：引数のオブジェクトのプロパティを列挙した2次元配列を返す
    - ex. `[[key, value], [key2, value2]]`のような形
  - `Object.assign()`：第一引数のオブジェクトに対して、第二引数以降のオブジェクトの（列挙可能な）プロパティを代入したものを返す（破壊的変更）
    - オブジェクトのマージや複製に使われる
    - ES2018以降、オブジェクトリテラルの中でSpread構文を使って、既存のオブジェクトをマージした新しいオブジェクトを生成することができる（ex. `const newObj = {...objectA, ...objectB}`）
    - この関数やリテラル内のspread構文はshallow copy（**コピー元のオブジェクトの直下のプロパティのみ**を複製する）なので注意
      - コピー元プロパティの値がオブジェクトや配列だった場合、コピー先のオブジェクトのプロパティの値にはその参照が渡されるので、**コピー元とコピー先でプロパティを共有してしまう**
      - 他の言語とは定義が少し違う？
    - deep copy（全プロパティについて、参照先を共有しない完全な複製を作る）はnpmでライブラリが存在する
    
### プロトタイプオブジェクト
- String, Array, Functionなどのほぼすべてのオブジェクトは、`Object.prototype`プロパティに定義された`prototype`オブジェクトを継承している
- プロトタイプメソッド：`toString()`などの、prototypeオブジェクトに組み込まれているメソッド
  - **あらゆるオブジェクト（`Object`のインスタンス）は、生成されたときにprototypeに定義されたプロパティやメソッドを継承する**
  - 空のオブジェクトからもプロトタイプメソッドは呼び出せる
  - 生成されたオブジェクトからprototypeオブジェクトに定義されたメソッドを参照できる仕組みをプロトタイプチェーンと呼ぶ
    - 同名メソッドがプロパティに定義されている場合はそちらが優先
- `in`演算子はプロトタイプオブジェクトまで遡ってプロパティの存在を確かめるが、`hasOwnProperty()`はそのオブジェクト自身のプロパティのみを探す
- `Array`などのオブジェクトも`Array.prototype`を持っており、`Array.prototype`は`Object.prototype`を継承している
### 配列
- JSにおける配列（Array）は可変長（≠Javaの配列）
- オブジェクト同様、存在しないインデックスにアクセスしても例外ではなくundefinedが返される
- 要素がlengthと同じ数含まれた配列を密な配列、そうでないものを疎な配列と呼ぶ
  - 要素がそのインデックスに存在するかどうかを確かめるのは`Object.hasOwnProperty()`を使う
- `typeof`演算子では結果はobjectになるので、判定には`isArray()`を使う
- インデックスの取得
  - `Array.indexOf()`は引数と厳密等価な要素のインデックスを返す
  - オブジェクトは、プロパティが同じでも参照が違えば厳密等価比較はfalseになるので、オブジェクト型の要素を探したい場合は代わりに`Array.findIndex()`を使う
- 要素の取得
  - `Array.find()`はコールバック関数の結果がtrueになる要素を返す
  - `Array.slice()`でPythonチックにインデックスの範囲指定で要素を取得できる
- 要素が含まれているかどうかを表す真偽値の取得
  - `Array.includes()`を使えるが、これも厳密等価比較
  - オブジェクト型の要素を検索する場合は`Array.some()`を使う。コールバック関数の結果がtrueになった時点で`some()`はtrueを返す
- 追加と削除
  - `push()`, `pop()`でstack操作、`unshift()`, `shift()`でqueue操作ができる
  - `concat()`で任意の配列や要素を末尾に結合でき、spread構文をリテラル中に書くことで、任意の位置に既存の配列を展開して新しい配列を生成できる
  - `Array.splice(idx, num)`で任意のインデックス番号以降のn個の要素を削除して詰められる
    - 第三引数に追加する要素を書くことで、削除と追加を同時に行うこともできる
  - `Array.length`プロパティに要素数を代入すると配列がその長さに切り詰められる仕様を使って、要素を削除できる
  - 空の配列を参照変数に代入することで、もとの配列を参照する変数がなくなってGC行きになる
  - `Array.flat()`で多次元配列の次元を削減することができる
- **配列操作は、メソッドが破壊的変更なのか、非破壊的変更なのかを注意**
- 配列の反復処理
  - `Array.forEach()`, `Array.map()`, Array.filter()`, Array.reduce()`がポピュラーで、全て高階関数
    - `forEach()`：コールバック関数の引数には、要素、インデックス、配列全体が渡される。非破壊メソッド
    - `map()`：同上。各イテレーションのコールバック関数の返り値から、新しい配列を生成する非破壊メソッド
    - `filter()`：同上。コールバック関数がtrueを返したイテレーションの要素から、新しい配列を生成する非破壊メソッド
    - `reduce()`：CB関数の引数には、累積値、要素、インデックス、配列全体を渡す。`reduce()`自体の第二引数に累積値の初期値を渡せる。
      - 累積値と各要素を順番にCB関数に渡していき、最終的な累積値を返す？
### 文字列、Unicode
- ほぼ配列の知識とPythonの知識で扱えそう、詳細Skip
- 正規表現オブジェクト：`/\s+/`のように/でパターン文字列を囲む正規表現リテラルで作成できる
  - 正規表現リテラルは、JSのソースコードがロードされた時点でパターンが評価される一方、`RegExp`コンストラクタでオブジェクトを作成すると、そのコンストラクタがプログラム内で実行されるタイミングでパターンが評価される
### ラッパーオブジェクト
- JSではプリミティブ型のデータに対してもプロパティアクセスが可能だが、これが可能なのは、対応するラッパーオブジェクトに都度自動変換されているから
### 関数とスコープ
- 関数定義が行われると、同時にその関数に紐付いたスコープが作成される
- スコープ：他の言語同様、変数や関数を参照できる範囲を定めるもので、スコープ内で定義されたものは基本的にスコープ外からはアクセス不可
- 関数スコープ：関数の仮引数、ローカル変数は関数の外からはアクセスできない
- ブロックスコープ：`{}`で囲まれた範囲も１つのスコープを形成する。for文は各ループごとに新しいブロックスコープを作成する
  - Pythonはifやforのブロックスコープを持たない
- スコープチェーン：スコープはネスト可能で、内側のスコープからは外側のスコープの変数を参照できる
  - 変数隠蔽：shadowingとも。内側のスコープで外側のスコープの変数と同名の変数を定義すると、外側の変数が参照できなくなる（内側の変数が優先される）
- グローバルスコープ：プログラム直下の最も外側のスコープのことで、暗黙的に作成される。ここに定義された変数をグローバル変数と呼び、あらゆるスコープから参照可能
  - ビルトインオブジェクトはグローバルスコープ上に自動で定義されるので、プログラムのどこからでも参照可能
  - 自作のグローバル変数とBIOとの名前衝突を避ける意味でも、無闇なグローバル変数宣言はNG
- `var`によるスコープの巻き上げ
  - 変数の巻き上げ： `var`を使って変数を宣言すると、実際に変数宣言する処理の前にその変数を参照した場合に、`Referrence Error`ではなくundefinedを返す（参照できてしまう）
    - 変数宣言自体は”最も近い関数スコープの先頭”or”グローバルスコープの先頭”で自動的に行われ、値の代入だけが実際にコード上に書かれた部分で行われる、という特殊な挙動が原因
  - さらに、`var`による巻き上げはブロックスコープの存在を無視する
  - `function`による関数宣言も`var`同様スコープの先頭に巻き上げられるが、通常の関数宣言であれば、`var`による変数の初期化とは違って宣言が完了した時点で呼び出し可能になるのであまり問題はない
    - **逆に言えば、関数式を`var`に代入する場合は、関数の呼び出し位置に注意する必要がある**
  - 結論→`var`は使うべきではない
- 即時実行関数：Immediately-Invoked Function Expressionとも
  - ES6以前の、`var`による変数宣言でのグローバルスコープの汚染を避けるために作られたイディオム
  - 匿名関数の宣言をカッコで囲んで関数式として解釈させ、その実行を同時に行うことで、任意の処理をその関数スコープの内側に閉じて実行できる
  - `let`や`const`の宣言はブロックスコープに正しく紐付けられるので、IIFEを使わなくてもブロックスコープ&`let`でグローバル汚染は避けられるようになった
- クロージャー：**関数が、自身の外側のスコープにある変数への参照を保持できる**という性質、またはそのような関数
  - これによって、関数が状態を持っているかのように動作することが可能
  - 静的スコープとGabage Collectionが関係している
    - 静的スコープ（レキシカルスコープ）：どの識別子がどの変数を参照するのかが、実行する前に（処理を定義した段階で）定まっている（静的）というJSの性質
      - 動的スコープ：呼び出し元に応じて、識別子が参照する変数が変わる仕組み（JSは静的）
    - GC：メモリ上のデータが参照されていなければそのメモリを解放する仕組み
      - 関数スコープで定義されたデータも、それが返り値として変数に代入されるなどして参照されていれば、関数の実行が終了してもメモリ解放はされない
  - クロージャーとは、**静的スコープとGCの仕組みを利用して、関数内から特定の変数を参照し続けることで、関数が状態を持つかのように動作できる仕組み**
  - privateな変数を定義する、グローバル汚染をへらす、動的な高階関数を定義するなどの目的で使われる
  - 関数はオブジェクトなので、プロパティで直接状態を持たせることも可能だが、関数外から関数オブジェクトのプロパティを操作できてしまうので非推奨
### 関数と`this`
- `this`：読み取り専用の変数のようなもので、どこで評価するかによって参照する先が変わる特殊なキーワード。基本的にメソッドにおける挙動を覚えておけばOK
- グローバルスコープで評価すると、Scriptモードなら`window`または`global`オブジェクト、Moduleモードなら`undefined`になる
- 関数やメソッドで評価すると、Arrow Functionでの関数定義とそれ以外で結果が変わる
  - Arrow以外だと、`this`は実行時に呼び出し元に応じて動的に定まる
    - Pythonにおける`self`引数の動きのように、その関数が属するベースオブジェクトが暗黙的に入る
    - ベースオブジェクトが無い＝メソッドではない関数の場合は`this`を使う意味はない
  - Arrowで定義された関数やメソッドの`this`の評価結果は、関数定義のときに静的に決定できる
    - 他の場合と異なり、`this`を暗黙の引数として受け取らない
    - Arrow Function内には`this`変数が存在しないとみなされるので、スコープチェーンによって最も近い外側のスコープの`this`を参照する
- `this`が問題になるパターン
  - `this`を含むメソッドを変数に代入した場合、メソッドとそれが属していたオブジェクトが切り離されるので、`this`によるベースオブジェクトの参照が`undefined`になる
    - メソッドを変数に切り出さずにメソッドはメソッドとして呼び出すことを徹底するか、`this`の値を指定して関数を呼べる`call`, `apply`, `bind`などの関数オブジェクトのメソッドを使って実行する
  - メソッドのコールバック関数で`this`を参照する際、コールバック関数は`callBack()`のようにベースオブジェクト無しで呼び出されるので、`this`が`undefined`になる
    - Arrow Functionでは`this`が暗黙的に渡されないので、自身では`this`を持たず、スコープチェーンによって外側のスコープに`this`を探す
      - メソッドのコールバック関数としてArrow Functionを渡せば、コールバック関数ではなく外側のメソッドの`this`を使うので、正しくベースオブジェクトを参照できる
### クラス
- JSのクラスはES6以降では`class`構文で定義され、内部的には関数オブジェクトの一種
  - 慣例的に関数を使って行われていたクラス定義の手順をパターン化した、糖衣構文の一種
  - 関数定義に関数宣言と関数式があるのと同じで、**クラス定義にはクラス宣言文とクラス式がある**
    - クラス式の定義方法は関数式の形と同じ
- クラスは必ず`constructor()`メソッドを持つ（省略した場合も空のコンストラクタが定義される）
  - 定義したクラスは`new`演算子でコンストラクタを呼び出すことでインスタンス化できる
  - コンストラクタの中で呼ばれる`this`は、インスタンス化されるオブジェクトを参照する
- クラスを関数呼び出しすることは出来ない（クラスはnewでインスタンス化すべきもの）
  - ES6以前の実装では、関数を使ってクラスを書くことが有ったが、混同を避けるために`class`構文で統一するべき
- クラスに定義したメソッドは、各インスタンスから共有される**プロトタイプメソッド**と呼ばれる
  - プロトタイプメソッドは各インスタンス間で共有される（同じ関数を参照する）
  - 一方で、コンストラクタの中で`this`に対してメソッドを定義すると、挙動は同じだが別個の関数オブジェクトをインスタンス化の度に定義する
  - プロトタイプメソッドとそうでないインスタンスメソッドのどちらも、クラスのインスタンスから呼び出せる点は同じ
    - メソッドが共有されるか否か、Arrow Functionの使用の可否（thisを静的に定められるか否か）が異なる
- アクセッサプロパティ：プロパティの参照、代入時に呼び出される特殊なメソッドで、それぞれ`get プロパティ名() {}`, `set プロパティ名() {}`と書くことで定義できる
  - getter, setterを拡張＆明示するためのもの？
  - getterは必ずreturn文で値を返す必要があり、setterは仮引数にそのプロパティに代入される値を取る
  - 標準のECMAScriptではプライベートプロパティは定義できない
- 静的メソッド（クラスメソッド）：クラス内の、インスタンス化せずに利用できるメソッド
  - メソッド定義の前に`static`をつけるだけでOK
  - クラスメソッド内で`this`を使うとそのクラス自身を参照するので、クラスメソッド内でコンストラクタを呼ぶ際は`return new this(args)`という風にも書ける

# Java
## Head First Java
### act7（継承とポリモーフィズム）
- 継承はIS-A関係  
- super.method()でサブクラスのメソッド内でスーパークラスのメソッドをCallできる  
  
- 継承は、あるスーパークラス以下のサブクラスが、スーパークラスのpublicなメンバーをすべて保持することだと言える  
  - サブクラスはスーパークラスの代理ができる。つまり、参照変数の型がスーパークラスで定義されている場合、実際にその変数が参照するオブジェクトはサブクラスでもOK  
  - **このように、変数宣言や引数、返り値の型をSuperClassで定義しておくことでよりコードが柔軟になる**  
    - その参照変数からメソッドを呼び出す場合は、変数宣言されたSuperClassの中でそのメソッドが定義されている必要がある（SubClass固有のメソッドは呼び出せない）
  
- コンパイラはコンパイル時に、参照変数として宣言されたクラスの型に対して検査をする  
- JVMは実行時に、参照変数が実際に参照しているオブジェクトの型に対して検査をする  
  
- オーバーライドはSuperClassの関数をSubClass内で上書きすること  
  - ポリモーフィズムを維持するために、オーバーライドの際は引数・返り値の型やアクセス修飾子を基本的にイジれない    
- オーバーロードは同名の別関数のようなもの  
  - メソッドの名前を維持したまま、引数の種類や数、順番を変更することで、オーバーロードとみなされる  
- シグネチャを変更せずに返り値の型のみを変更するとオーバーライドとみなされるので、SuperClassのメソッドとSubClassのメソッドの返り値に互換性が要求される  
  
  
### act8（抽象クラスとインターフェース）  
- インスタンス化すべきでない共通クラスを抽象クラスとして定義することができる。抽象クラスはそのまま参照変数の型としても使える  
- 抽象メソッドが存在するクラスは抽象クラスである必要がある  
- 抽象クラスは具象メソッドと抽象メソッドを両方持てる
- **抽象メソッドの存在意義は、実際のコードを実装する前に、サブクラス一般に適応されるべき規約を定義できることにある**  
  - 「この抽象クラスを継承したクラスはすべて、この抽象メソッドの実装を持っている」ということが分かる  
- 参照変数からメソッドを呼び出せるのは、その変数の宣言されたクラスの中で実際に呼びたいメソッドが定義されている場合だけ  
  - つまり、Object型として定義した変数に何らかのインスタンスを代入して、そのクラス特有のメソッドを呼び出させる、といったことは不可能  
  - コンパイラは、実際のオブジェクトの型ではなく、それが格納される参照変数の型でメソッドを呼び出せるかどうか判断する  
  
- Polymorphism＝many forms→あるオブジェクトを、Object型、SuperClass、具体的なSubClassなど多様な形で扱えるということ  
- instanceOf演算子→何らかのインスタンスを参照するObject型の変数をキャストする際のランタイムエラーを避けるために使われる 

- Interface：抽象メソッドと`public static final`な定数のみで構成される  
  - **存在意義→継承関係とは別に、あるクラスにのみ共通する「役割」を定義したい場合に役立つ**  
  - ex1. Hippo, Lion, Tiger, Dog, Catなどの、AnimalをSuperClassとするSubClassが複数あり、その中のDog, CatクラスにだけPetとしての役割を持たせる  
  - ex2. あるインスタンスをファイルに保存したければSerializableインターフェースを実装すればいいし、そのインスタンスを別のスレッドで実行できるようにしたければRunnableインターフェースを実装すればいい  
  
- 多重継承（同時に複数からの継承を行うこと）について、クラスでは出来ないがインターフェースなら可能  
  - Javaでは、2つの親クラスから同名の具象メソッドやインスタンス変数を継承してしまった場合の名前解決が出来ないので、クラスの多重継承はできない様になっている  
  - Interfaceは、全てのメソッドを抽象メソッドとして定義されたもの  
    - 上述の、複数クラスの継承を許した場合に、メンバがコンフリクトしてしまう問題を、メソッドの実装を継承先のSubClassに完全に任せることで解決する
    - **複数のInterfaceから同名メソッドを継承してしまったとしてもそれらは全て抽象クラスであり、それらの同名メソッドが実際に行う処理の内容は継承先の実装に依存するため、コンフリクトはそもそも起こり得ない**  
- Interfaceは、通常のSuperClass同様、Polymorphism的にコードを書くのに役立つ  
  - 異なる継承関係にあるSubClassにおいても共通のInterfaceを実装することが可能  
  - ex.参照変数や引数、返り値の型にInterfaceを指定することで、それをImplementしているSubClassをすべて（継承関係があるか否かに関わらず）受け入れることが出来る  
  - 継承できるSuperClassは1つだけだが、実装できるInterfaceは複数→親子関係と、その他の肩書・役割のメタファー  
  
- クラス、IF設計の判断基準  
  - 他のクラスに対してIS-Aテストが通らないようなクラスが必要な場合、それは既存の継承関係と独立したクラスとして実装する  
  - 他のクラスのより詳細な（用途限定的な）クラスが必要になった場合、既存のクラスを継承するSubClassとして実装する  
  - いくつかのクラスに共通するメソッドの実装が存在してそれを括り出したい場合や、そのクラス自体をインスタンス化してほしくない場合は抽象クラスとして実装する  
  - クラスごとの継承関係に関係なく、共通する役割を定義したい場合はInterfaceを実装し、各クラスにImplementさせる  
    
 
### act9（コンストラクタとGarbage Collection）  
- JVMが起動すると、一定のメモリ領域をJavaプログラムのためにRAMから確保する  
- オブジェクトが記憶されるのは**Heap**で、ローカル変数やメソッドの呼び出しが記憶されるのは**Stack**と呼ばれる領域  
  - インスタンス変数はオブジェクトの一部なのでHeapに記録される  
  - ここでいうローカル変数は、（引数を含む）メソッドの内部で宣言される変数のこと  
  - ローカル変数として何らかのオブジェクトがインスタンス化された場合も、オブジェクトそのものは**常にHeap上に初期化される**一方で、その参照自体はStack上に保持される  
- 新しくメソッドが呼び出されるとStack内のトップのフレームに配置され、ローカル変数などの状態がメソッド終了まで保持される  
  - Stackのトップにあるメソッド＝そのとき実行中のメソッド、が常に成り立つ  
- Heap上に確保されるオブジェクトのためのメモリ領域は、インスタンス変数の要するメモリ領域に応じて定まる  
  - オブジェクトのインスタンス変数にint型が1つだけあれば、32ビット分のメモリが確保される  
  - インスタンス変数がPrimitiveではなく参照型だった場合、オブジェクトへの参照（メモリアドレス）用のメモリだけが確保される（実際にオブジェクトが初期化されて代入されるまで、その変数はnullのまま）  
  - あるSubClassがHeap上にインスタンス化される際には、それが継承したSuperClassのインスタンス変数もHeap上に保持されることになる  
  
- オブジェクト生成のプロセスは、参照型変数の宣言、コンストラクタによる初期化、参照変数とオブジェクトの紐付けの3段階に分解できる  
  - 開発者が定義しない場合コンパイラがデフォルトコンストラクタを定義する  
  - コンストラクタの特徴は、オブジェクトが参照変数に代入される前にその処理が実行されること  
    - 基本的には、インスタンス変数を宣言して状態を初期化するのに使われる  
    - コンストラクタの要件は、返り値を持たず、名前がClassと同じであること  
    - Classと同名のメソッドを定義すること自体は可能（返り値の有無でメソッドorコンストラクタは区別される）  
    - メソッドオーバーロードのように、コンストラクタも引数を取るものとそうでないもので2つ用意することが可能  
    - デフォルトコンストラクタが自動で定義されるのは、開発者がコンストラクタを1つも実装していない場合だけ  
    - セッターだけではなく、コンストラクタに引数を渡してインスタンス変数を初期化できるようにしておくべき（一回のnewの呼び出しでオブジェクトを初期化出来るようにしておく）  
- SubClassをnewするとき、内部的にはSuperClassのコンストラクタも順に実行されていく（コンストラクタの呼び出しはStackで管理されるので、先にSuperClassのコンストラクタの処理が終了する）  
  - SuperClassのコンストラクタの呼び出しは、super()をSubClassのコンストラクタ内に書くことで明示的に実装できるが、書かない場合もコンパイラが勝手に実行してくれる（書く場合は、SubClassコンストラクタのどの処理よりも先に書く必要がある）  
  - SuperClassコンストラクタに引数を渡すことで、継承したSuperClassのフィールドに値を渡すことが出来る

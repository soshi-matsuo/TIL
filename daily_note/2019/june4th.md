# Java
## 言語仕様
**特殊な型**  
- enum：列挙型とも呼ばれる、クラスの特殊系。定数の集合を保持するために使われることが多い  
- ジェネリクス：総称型とも呼ばれる。一部の特定の型に紐付けられる抽象的な型で、`ArrayList`などの複数の要素を扱うような型において、要素の型を任意の型に限定することが出来る  
  - ex. `List<String> list = new ArrayList<>();`とすることで、要素の型をStringに限定したリストが宣言できる  
  - ジェネリクスを使ったクラスを作成する際は、`public class GenericExample<T>`のようにクラス名に仮型パラメータを設定する  
  
**配列とコレクションフレームワーク**  
- 複数のデータを纏めて扱う仕組みには、大別して配列とコレクションの2種類がある  
- 配列：インデックスで要素を指定する固定長配列で、要素数や内容が定まっている場合に使われる  
- コレクション：可変長で、任意の数の要素を格納できる。List, Map, Setなどが代表的なインターフェースとして存在する（各々異なる実装を持つ）  
  - 繰り返し処理の際に、コレクションをそのままfor文にわたすだけではなく、コレクションからIteratorインターフェースを生成したものをfor, while文に渡して処理を行うことで、例えばコレクション内の要素の削除など（Iteratorが持つメソッドを使って）個々の要素に対する操作を行いながら繰り返し処理が出来る  
  - Mapのキーの性質とSetの要素の性質は一意性制約の点で共通しており、この性質を活かして、Setの内部実装にはMapが使われている。（Setに追加される要素は内部的にはMapのキーとして保持される）  
  
**例外処理**
- 検査例外（Exception）：プログラム作成時に想定可能な例外。APIの通常の使い方で発生しうるようなものが該当する？  
  - `catch`ブロックで補足するか、そのメソッドの呼び出し元に対してthrowすることが求められる
- 実行時例外（RuntimeException）：想定外の例外。ゼロ除算や型エラーなど、そのAPIが想定していない使い方をすると発生する  
  - プログラムで補足する必要はない。無条件で例外発生コードの呼び出し元で発生する
- エラー：システム動作を停止すべき致命的なエラー（スタックオーバーフローなど）  
- 処理の基本として、「スタックトレースをログに出力する」「テキトーに`throw Exception`を書かない（弊害が大きい）」「処理を中断するか、継続するならデフォルト値を設定する」などのBPがある
  
**文字列操作**
- **`String`は内部的には`char`（一文字を表す型）の配列として実装されている**
- `String`オブジェクトは一度作成すると、そのオブジェクトそのものを変更することはできない
- Javaにおける文字列の結合には`StringBuilder#append()`、`+`演算子、`String#concat()`の3つの手段がある。可読性は`+`が最も良いが、ループ処理でのパフォーマンスは`StringBuilder`が最も良い。
  - ex. ループの回数分`"a"`を足していくような処理を考える  
  - `+`では以下のように、ループのたびにオブジェクトを生成している  
  - `str = new StringBuilder(String.valueOf(str)).append("a").toString();`  
  - `String#concat()`ではループのたびに、要素数が追加文字列分大きい配列を生成して古い配列をそこにコピーし、末尾に新しい文字列を追加するという処理を行っている
  - 反面`StringBuilder`は、最初から配列の要素数を余裕を持って確保しているのでメモリ確保処理が少なくて済む
- `util.regex`や`String`のメソッドで正規表現処理ができる
- 文字列をフォーマットする（書式文字列を用いて、パラメータとして受け取る文字列の表記を操作する）には、`System.out.printf()`や`MessageFormat#format()`を使う
  
**値渡し（変数への代入や、メソッドの引数へ値を渡すこと）について**
- プリミティブ型の値渡しと、参照型の値渡しで挙動が変わる  
  - プリミティブ型の値を他のメソッドの引数に渡して、渡した先で値に変更を加えても、呼び出し元の値には変更は影響しない。これは、**プリミティブ型の値が渡される際は、値を複製したものが呼び出し先に渡される**から  
  - 反面参照型の値渡しでは、呼び出し先でオブジェクトの値を変更すると呼び出し元のオブジェクトにも変更が反映される。これは、**参照型の値が渡される際は、オブジェクトではなくポインタ（メモリ上のオブジェクトの格納アドレス）の複製が呼び出し先に渡されて、結果として呼び出し元と呼び出し先で同じオブジェクトを参照する**から  
    - 呼び出し先で別のオブジェクトを代入するとポインタが書き換わり、呼び出し先の変更は呼び出し元に影響を与えなくなる  
- ラッパークラスやString型はイミュータブルクラスと呼ばれ、これらのオブジェクトは一度生成されると値そのものを書き換えることはできず、値渡しを行って値を変更しても渡し元には影響がない（値を変更するようなメソッドでは別のオブジェクトを生成して返している）  
  - 逆に言うと、StringやIntegerへの頻繁な値の変更はオブジェクトの新規生成を必要とするので、多すぎるとパフォーマンスに影響を与える  
- イミュータブルクラスとは逆にミュータブルクラスも存在する。実行することでオブジェクト自身の値を書き換えられるメソッドを持つクラスが当てはまり、値渡しでは、渡した先での変更が元のオブジェクトにも影響する  
  
**オブジェクトライフサイクルについて**
- オブジェクトライフサイクル：オブジェクトが生成されて破棄されるまでの期間のことで、変数のライフサイクルはローカル変数、インスタンス変数、クラス変数で分かれている  
- ローカル変数：処理のブロック内でのみ利用可能な変数で、宣言した箇所で生成され、ブロック終了時点で破棄される。**関数に限らず、ifやforなどブロック( { } )で囲まれた部分で宣言された変数が該当する**  
- インスタンス変数：クラス内の非staticなフィールドとして宣言される変数で、オブジェクト（インスタンス）の生成とGCによる破棄と同時に生成・破棄される  
- クラス変数：クラスのstaticなフィールドとして宣言される変数。Javaプロセス起動時に生成され、終了時に破棄される  

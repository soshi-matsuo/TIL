# セキュリティとSSL/TLS
## 情報セキュリティ概略
情報セキュリティとは、扱う情報の機密性、完全性、可用性を維持すること。  
- 機密性（Confidentiality）：許可されたものだけがその情報にアクセスできること  
  - 実装技術：認証、認可によるアクセス制御など  
- 完全性（Integrity）：情報が改ざん、破壊されないでいること  
  - 実装技術：デジタル署名など  
- 可用性（Availability）：アクセス許可のあるものが、必要な時に情報にアクセスできること  
  - 実装技術：RAID構成、システムのクラウド化・二重化  
  
## セキュア通信
セキュアな通信とは、後述の情報セキュリティが保たれた状態で行える通信のことである。  
特にSSL/TLSを使ったセキュアなHTTP通信をHTTPS（Hyper Text Transfer Protocol Secure）と呼び、他にもSSH（Secure SHell）など。  
- SSL/TLS：セキュア通信のためのプロトコルで、**通信相手の認証、通信内容の暗号化、改ざんの検出**を行う機能がある。
  - それぞれSecure Sockets Layer、Transport Layer Securityの略
  - SSLの次世代型としてTLSが開発されておりまとめて扱われることが多いが、現在実際に運用されているのはTLS
  
## SSL/TLSの要素  
通信条件等の共有に加えて、後述の認証、鍵交換フローを達成して通信を確立するまでのプロセスを**ハンドシェイク**と呼ぶ。  
- 暗号スイート（Cipher Suites）：SSL通信のどのフェーズでどの暗号を利用できるか、という決め事の組み合わせのことで、ハンドシェイクの最初にC/Sの合意で決まる（`openssl ciphers -v`で確認可能）  
  
上述の通り、通信相手の認証、通信内容の暗号化、改ざんの検出の3要素でセキュアな通信を実現している
### 通信相手の認証
#### 概略
問題：そのサイトが、利用者のアクセスしようとしている正規のものであるという保証がない  
解決策：SSL証明書（サーバ証明書などとも）  
- 信頼できる第三者（認証局）によって発行される、そのサーバが認証済みである証明で、HTTPSスキームを持つサイトはこの証明書を保持している
  - 最上位の認証局はルート認証局、ルート認証局以下の認証局は中間認証局と呼ばれる
  - ルート認証局自体の認証は、予めブラウザに信頼できる存在として登録することでなされている（社会的信頼に基づく）
- オレオレ証明書：自己署名証明書の俗称
  - 通信内容の暗号化そのものはこれでも可能だが、通信相手の認証に認証局が関与していない、つまり認証になっていない状態なので、MITM攻撃を避けられず、結局通信内容は攻撃者に筒抜けになる
  - 上記の理由より、外部のインターネットと通信しうるサーバに用いてはいけない
#### 認証フロー
- サーバは公開鍵と秘密鍵のペアを生成（ここで公開鍵生成に使用する暗号アルゴリズムが認証アルゴリズムと呼ばれる）  
- サーバは自らの情報と公開鍵を併せてcsr（証明書発行要求）を作って認証局に送付  
- 認証局はcsrにデジタル署名を行い、csr+署名をSSL証明書としてサーバに返送  
  - **デジタル署名：文書の生成者と、その文書が改ざんされていないことを保証する**  
    - メッセージダイジェストと公開鍵暗号を組み合わせて実装する  
    - 送信者は「送りたい文書をハッシュしたもの」を「署名用の秘密鍵で暗号化したもの」を署名として文書本体に添付  
    - 受信者は、署名を「送信者の公開鍵で復号したもの」が、「文書本体をハッシュ化したもの」に一致すれば、上記2点を信頼できる  
- サーバは、クライアントからの接続要求を受けるとSSL証明書を送付  
- クライアントは以下の4点の検証が成功すると認証完了とみなし、証明書に含まれる公開鍵を使って共通鍵交換に移る  
  - 有効期限：SSL証明書の有効期限が切れていれば警告  
  - ルート認証局：SSL証明書の認証チェーンに記載されているルート認証局が「信頼できる認証局」としてシステムに登録されていなければ警告  
  - デジタル署名：署名を認証局の公開鍵で復号出来ないor復号した結果が違う場合警告  
  - ホスト名：SSL証明書記載のホスト名と、現に接続しているホスト名が一致していない場合警告  
    
### 通信内容の暗号化
#### 概略
問題：平文で内容を送ると攻撃者に盗聴された時に読まれてしまうので暗号化が必要だが、結局復号のための鍵を受信者にどのように渡せば良いのか  
解決策：公開鍵暗号  
#### 公開鍵暗号方式
- 元々のコンセプト  
  - 送信者、受信者が各々の自分の鍵を管理しておく（鍵1,鍵2とおく）  
  - 送信者が鍵1でメッセージを保護して送信  
  - 受信者が鍵2でさらに保護して返送  
  - 送信者が鍵1による保護を解除し、再送信  
  - 受信者が鍵2で残った保護を解除し、メッセージの受け取りが完了  
- 上記コンセプトに基づいたフローで暗号化が実現される  
  - 受信者は、暗号化用の鍵を公開鍵として公開し、復号用の鍵は秘密鍵として秘匿しておく
  - 送信者は、受信者から暗号化鍵を取得してメッセージを保護、送信する
  - 受信者は、秘密鍵を使って復号し、メッセージの受け取りが完了  
- 公開鍵暗号方式では、暗号化鍵が公開されている仕組み上、**「暗号化の方法が分かっても復号できない」という不可逆な暗号アルゴリズムが必須**  
  - RSA：「素数から合成数を得る」計算と「合成数から素数を得る」計算について、計算量の非対称性（処理の一方向性が担保される）があることを利用した暗号
    - 前方秘匿性の欠如：RSAのように使用する鍵がずっと同じものである場合、もし秘密鍵が解読されてしまうと過去や未来の暗号通信にも被害が波及する、という問題があり、現在の仕様では「鍵交換方式として」RSAを利用することは禁止されている
  - DH(diffie-hellman)：pが大きな素数の時、x^y = z mod pという式において、x, y, pからzを求めるのは簡単だが、x, z, pからyを求めるのは難しいという計算量の非対称性（処理の一方向性）があることを利用した暗号
    - 前方秘匿性が保たれる
#### 鍵交換
公開鍵暗号方式は、共通鍵暗号（暗号化と復号に使う鍵が同じ）より計算コストが高く、処理が遅いのが難点。  
なので、実際は**鍵交換**と呼ばれるプロセスで、公開鍵を使って共通鍵の受け渡しをすることで、セキュリティと効率を両立する。  
- 簡略化した鍵交換フロー  
  - SSL認証を行いつつ、送信者が受信者の公開鍵を取得
  - 送信者はセッションでワンタイムの共通鍵を生成して、公開鍵で暗号化して受信者に送信
  - 受信者は秘密鍵で復号し、共通鍵の安全な共有が完了  

    
### 改ざんの検出
#### 概略
問題：サーバから見て、クライアントから送られてきた通信内容が正しいと確認できない  
  - 暗号化によって傍受は防げたとしても、そのデータの完全性は保証されない    
  
解決策：データと併せてメッセージダイジェスト（Message Authentication Code, Mac）を送信することで、受信者側で内容の完全性を検証できる  
- 改ざん検出のフロー  
  - 送信者は、データと、それに基づいて生成したメッセージダイジェストを送る  
  - 受信者は、データを元に再度メッセージダイジェストを計算して、受け取ったメッセージダイジェストと照合し、一致すればOK  
- 上記フローを達成するためには以下の性質が必要で、具体的にはハッシュ化などで実装する  
  - 元データがほんの少しでも違うとダイジェストの内容が変わる  
  - 元データを使わずにダイジェストとデータの整合性を保つのが非常に困難  
- ハッシュ化：元データを何らかのハッシュ関数（SHA1, SHA2, md5等）で不可逆変換すること  
  - 暗号化は、鍵を使って元データを得ることが出来る点でハッシュ化とは全くの別物  
  - 同じアルゴリズムを使えば固定長になり、ハッシュのデータ量は元データには依存しない  
- 実運用では、ペイロード以外のデータも使ってHMAC（Hash-based MAC）と呼ばれるダイジェストを生成する  

# JS Primer
## 1.基本文法
### JavaScriptとは
- **ウェブブラウザ上で動く**言語
- ECMAScript：どんな実行環境でも共通のJavaScriptの動作を定義した仕様
  - 例えば、Node.js上の機能はECMAで定義されたものだが、ブラウザ上のJavaScriptとは別
  - ES6(ECMAScript2015)がでかいアプデ
- JSにおけるほぼ全てはオブジェクト（値と処理をまとめたもの）であり、プログラムの処理はオブジェクトのコミュニケーションで成り立っている
  - ECMAの仕様で定まったオブジェクト、JSやNodeなどの実行環境によって定まったオブジェクト、ユーザー定義のオブジェクトが存在する
- 実行の際はScript, Moduleの2つのモードが存在する。基本は前者で、後者はJSのプログラムをモジュール化して扱うための機能
### 変数宣言
- `const`：**値を再代入できない変数**の宣言と、初期値の定義を行う
  - 参照透過性（変数の値は最初に定義した値から変化しない）を維持する機能
  - 定数になるわけではない（もしプリミティブを代入すれば定数とみなせるが、オブジェクトを代入した場合、オブジェクトのプロパティは変更できてしまう）
- `let`：**値の再代入が可能な変数**の宣言を行う（初期値未定義でもOK）
- `var`：letとほぼ同じ機能だが、挙動に問題があるのでES6以降はletかconstで書くべき（関数スコープの項参照）
### 値の評価と表示
- JSにおける「評価」→式や変数の結果を返すこと？
- JSの実行方法
  - ブラウザのDeveloper ToolのREPL
    - 入力の評価結果は、次の行に自動で表示される
  - JSファイルを`<script>`タグでHTMLファイルから読み込みブラウザでレンダリング
    - JSファイルのコードの評価結果は勝手には表示されない
    - Console API：値を評価してコンソールへの表示を行うための機能
### データ型とリテラル
- 動的型付け言語なので変数の型は存在しないが、数値・真偽値・文字列などの値自体の型（データ型）は存在する
- プリミティブ型（基本型）
  - 真偽値、数値、文字列、undefined、null、シンボルが当てはまる（文字列もプリミティブ）
  - 一度作成したら、その値自体を変更することは出来ない（Immutable）
- オブジェクト型（複合型）
  - プリミティブ型以外のデータで、オブジェクト、配列、関数、正規表現など
  - 複数のプリミティブorオブジェクトで構成される集合
  - 作成したあとも値自体を変更可能（Mutable）
  - 参照変数を経由して扱われるので、参照型のデータとも
- `typeof`演算子でPorOを判定可能
- リテラル：記述した内容が直接そのデータ型の値になる、という構文で、一部のデータ型はこれで簡単に定義できる。以下の型にはリテラルが存在
  - プリミティブ：真偽値、文字列、数値、null
    - テンプレートリテラル（ES6以降）：バッククオートで囲んだ範囲を文字列として定義する。変数のプレースホルダを入れたり、\nを使わずに改行できる
    - null：「値がない」ことを表す値。値が未定義の変数は参照できないが、値がnullの変数は参照できるので、ランタイムエラーを避けられる
  - オブジェクト：オブジェクト、配列、正規表現
    - オブジェクトリテラル：`{}`の中にkey:valueを書くことでオブジェクトを定義＆初期化できる。オブジェクトの持つキーをプロパティと呼び、`obj.key`or`obj["key"]`で値を参照できる
      - プリミティブの値でもオブジェクトのようにプロパティアクセスが可能（ex. `str.length`）
    - 正規表現リテラル：`//`で囲んだ中に正規表現のパターンを書くことで、正規表現オブジェクトを定義できる
    
### 演算子
- 比較演算子に注意
  - `===`：厳密等価演算子。同型＆同値の場合にtrueになり、オペランドがオブジェクトの場合は参照が同じ（Heap上の同じオブジェクトを指している）ときにtrueを返す。`!==`は異型or異値の場合にtrueを返す（厳密等価の逆）
  - `==`：等価演算子。オペランドが同型の場合は厳密等価と同じ挙動になるが、型が違う場合に暗黙型変換を行ってから比較するので意図と違う挙動になりがち。基本的に使うべきではない
- 分割代入（ES6以降）：配列やオブジェクトの値を、同時に複数の変数に代入できる（Pythonのタプルアンパッキングに近い）。右辺の配列やオブジェクトの値を、左辺の配列リテラルやオブジェクトリテラルの対応する変数名に代入する
  - 配列の分割代入：`const array = [1, 2]; const [a, b] = array;`とすると、arrayの0番目、1番目の要素がそれぞれa, bに代入される。`const a = array[0]; const b = array[1];`と同じ動作
  - オブジェクトの分割代入：右辺のプロパティの値を、左辺の対応するプロパティ名を持つ変数に代入する（ex. `const {a, b} = {a : 1, b : 2}`とすると、変数a, bの値に1, 2を代入できる）
- 三項演算子：`条件式 ? Trueの時処理する式 : Falseの時処理する式;`と書くことで、条件式を評価した結果がTrueなら二項目の評価結果を、Falseなら三項目の評価結果を返す
  - 条件によって変数の初期値が変わる場合などに使われる
- 論理演算子：&&, ||は、「左辺を評価した段階でT, Fが確定した場合には右辺を評価しない」という短絡評価（ショートサーキット）を行う

### 暗黙型変換と明示的型変換
- falsyな値：false, undefined, null, 0, NaN, ""の6つの値は、`Boolean()`に渡したり、条件式に渡して暗黙型変換を行ったりするとfalseになる。これ以外は全てtrue
- 特に真偽値について、型変換で求める値を得ようとするのは正確性に欠けるので注意
- `String()`での変換はプリミティブに使うよう留めるべきで、オブジェクト型は各々固有の文字列変換方法が存在する
- `Number()`で明示的に数値型への型変換ができるが、互換性のない値を変換するとNaNが返される
- NaNは何と演算してもNaNになるので、計算過程でNaNが生じると結果は必ずNaNになる。また、NaNは自分自身と一致しないという特殊な性質がある
### 関数と宣言
- 関数を定義する手法は、**`function`キーワードによる関数宣言、`function`を使った関数式、Arrow Functionを使った関数式の3つ**
- 値を返さない関数ではreturn文の返り値を省略したり、`return;`そのものを省略したりできる。その場合はundefinedが返される
- JSでは、シグネチャ上の仮引数の個数と、実際に関数を呼び出した際に与えた引数の個数が一致していなくても関数呼び出しが実行できる
  - 渡した引数が少ない時→余った仮引数にはundefinedが代入される
    - デフォルト引数（ES6以降）：Pythonと同様の書き方で、引数が与えられなかった場合のデフォルトの値をセットできる
  - 渡した引数が多い時→溢れた引数は無視される
- 可変長引数：渡される数を限定しない引数
  - Rest Parameters（ES6以降）：残余引数とも。`function test(...args) {}`のように仮引数の前に...を付けて関数定義すると、渡された引数は`args`に配列として代入される
    - 通常の仮引数とも併用可能で、その際の残余引数は仮引数の末尾で定義しなければいけない
    - 残余引数を受け取る関数に対して、既存の配列をSpread構文（配列の前に...を付けた構文）で展開して引数として渡すことも可能
  - `argument`変数：非推奨
- 分割代入は関数の引数に対しても使える
- JSでは**関数もオブジェクトの一種で、`()`をつけると関数としての処理を呼び出し、`()`を付けない場合は他のオブジェクト型と同じようにオブジェクトとして参照できる**（変数への代入や引数として渡すことができる）
  - 関数が値として扱えることをファーストクラスファンクション（第一級関数）と呼ぶ
  - 関数定義したものを値として扱うのではなく、**最初から値として関数を定義する**方法もあり、これらは**関数式**と呼ばれる
- 関数式：関数を、値として生成している式のこと（通常の関数宣言は文）で、変数への代入や引数への値渡しの際に見られる
  - `const myFunc = function() {};`のように、無名関数を左辺の変数に代入することで、変数名をトリガーにして右辺の関数を参照できるようになる
  - Arrow Function（ES6以降）：functionキーワードを使わずに無名関数を定義して左辺に代入する
    - `const 関数名 = (引数) => {処理};`が基本形
    - 関数の仮引数が一つのときは、引数を囲む`()`を省略可能
    - 処理が1つの式である場合は、`{}`によるブロック定義とreturn文を省略できる（その式の評価結果を返り値と見なす）
    - Arrow Functionは常に匿名関数
    - `argument`変数は使用不可
    - `this`の挙動がfunctionキーワードとは別
  - 可読性的には、基本的にArrow Functionで書き、問題がある場合にのみfunctionを使うべき
- JSにはオーバーロードは存在せず、同じ名前の関数が複数存在する場合は、あとに定義されたものに上書きされる
- コールバック関数：高階関数に引数の値として渡される関数のこと
  - 毎度事前にコールバック関数を定義してそれを引数に渡すのは面倒なので、高階関数の呼び出し時に関数式を使って無名関数を定義してコールバック関数を渡すことが多い
  - ex. `const array = [1, 2, 3]; array.forEach(value => { console.log(value) });`としたときのforEachが高階関数、その引数がコールバック関数
- メソッド：オブジェクトのプロパティとして定義された関数のこと
  - ES6以降ではオブジェクトリテラルに直接`メソッド名() {処理}`と書くことでメソッドが定義できる
### 文と式
- JSの要素は文（Statement）と式（Expression）
- 式：**値を生成し、変数に代入可能なもの**を式と呼ぶ
  - 具体的にはリテラル、変数や関数の呼び出し、式＆演算子の組み合わせのこと
  - 評価すると結果の値が得られ、それが**評価値**と呼ばれる。例えば、関数式の評価値は関数オブジェクトであり、そのオブジェクトは変数に代入可能
- 文：セミコロンで区切られた、処理の１ステップを文と呼ぶ
  - ifやforなどが文の具体例で、文中には式が含まれる
  - 文は式ではないので、変数への代入は出来ない
  - ブロック`{}`で囲まれた中には複数の文を書くことが出来る。また、ブロック文の末尾は例外的にセミコロン不要
- 式文：文が書けるところにはどこでも式を書くことができ、文になった式（処理のステップとして扱われる式）はセミコロンで区切られる
- 関数宣言と関数式：前者は文で後者は式
  - 関数宣言は「ブロックで終わる文」なのでセミコロン不要
  - 関数式の代入文は、「式の評価結果を変数に代入する通常の文」なのでセミコロンが必要
### 条件分岐
- switch文の用法は限定的で、関数の引数に受け取った値に応じて、決まった返り値を返すためのパターンを実装するのに使われる（returnがbreak代わりになって記述量が減らせるから？）
### 反復処理
- ループ処理≒配列に入れた要素を処理する手段といえる。なのでfor, while, do-while以外にも、配列オブジェクト自体に反復処理用のメソッドが実装されている
  - `Array#forEach()`は、配列の要素が先頭から順にコールバック関数に渡されて処理が実行される
  - `Array#some()`は、コールバック関数が一度でもtrueを返したら反復を終了してtrueを返す
  - `Array#filter()`は、コールバック関数がtrueを返した要素のみを集めた新しい配列を生成して返す
  - `Array#reduce()`は、配列の要素を2つずつコールバック関数に適用していき、コールバック関数が最後に返した値を返り値として返す
    - `reduce()`を使った反復処理では、通常のfor文などのように変数を更新していく必要がないので参照透過性が保ちやすい
- for inは非推奨
- for of文（ES6以降）：JSでは`Symbol.iterator`メソッドを実装したオブジェクトをiterableと呼び、iterableなオブジェクトを反復処理するのがfor of文
  - Arrayもiterableオブジェクトの１つ
  - 通常のオブジェクトはiterableではないので、反復処理するためには、`Object.values()`, `Object.keys()`, `Object.entries()`などでプロパティを配列として取得しておく必要がある
  - JSではStringオブジェクト（ラッパー？）もiterableオブジェクト
- 反復処理は大別して、**for, whileなどの構文を用いるか、配列のメソッド＆コールバック関数を使うか**の2つの手段に分けられる
### オブジェクト
- プロパティ（名前（key）と値（value）のペア）の集合がオブジェクト
  - キーは文字列orSymbolで、値には任意のデータが入る
- あらゆるオブジェクトのもととなるビルトインオブジェクト（どの環境でも利用可能な組込みオブジェクト）が`Object`として存在する
- オブジェクトリテラルで作成する
  - キーは、ハイフンを含まない限り""で囲まなくてもOK
  - プロパティの値に変数名を指定すると、そのプロパティのキーは指定された変数を参照する
    - ES6以降、プロパティのキー＝プロパティの値に指定する変数の名前、な場合は`const obj = { someVar };`のように省略記法でプロパティを設定できる。この例だと、objには`someVar: someVarの値`というプロパティがセットされる
  - オブジェクトリテラルは、`new Object()`として`Object`の新しいインスタンスを生成しているのと同じ処理
- プロパティの参照にはドット記法とブラケット記法があるが、基本的には簡潔な前者を使う
  - ブラケット記法では、「書かれた任意の式（変数など）の評価結果を文字列に変換したもの」をプロパティ名として扱うので、ドット記法で書けない動的な場合などにはこちらを使うべき
  - ES6以降、オブジェクトをリテラルで生成する際にも、プロパティ名をブラケット記法で書くと、`[]`内の式の評価結果がプロパティ名になる（Computed property names）
- プロパティを完全に固定するためには、Strictモードで`Object.freeze()`に固定したいオブジェクトを渡す
- **JSでは、存在しないプロパティを参照すると例外ではなくundefinedを返す**
  - undefinedはオブジェクトではないので、それに対してプロパティを参照しようとして初めて例外が生じる
  - プロパティの存在を確かめるには`in`演算子orオブジェクトの`hasOwnProperty()`を使う
    - プロトタイプオブジェクト関係でこの2つの動作は少し異なる？
- オブジェクトを文字列化すると`toString()`が実行され、`"[object Object]"`という文字列になる
- `Object`の静的メソッド→オブジェクト型のインスタンスのメソッドとしてではなく、BIOの`Object`から直接呼び出せるメソッド
  - `Object.keys()`：引数のオブジェクトのキーを列挙した配列を返す
  - `Object.values()`：引数のオブジェクトの値を列挙した〜
  - `Object.entries()`：引数のオブジェクトのプロパティを列挙した2次元配列を返す
    - ex. `[[key, value], [key2, value2]]`のような形
  - `Object.assign()`：第一引数のオブジェクトに対して、第二引数以降のオブジェクトの（列挙可能な）プロパティを代入したものを返す（破壊的変更）
    - オブジェクトのマージや複製に使われる
    - ES2018以降、オブジェクトリテラルの中でSpread構文を使って、既存のオブジェクトをマージした新しいオブジェクトを生成することができる（ex. `const newObj = {...objectA, ...objectB}`）
    - この関数やリテラル内のspread構文はshallow copy（**コピー元のオブジェクトの直下のプロパティのみ**を複製する）なので注意
      - コピー元プロパティの値がオブジェクトや配列だった場合、コピー先のオブジェクトのプロパティの値にはその参照が渡されるので、**コピー元とコピー先でプロパティを共有してしまう**
      - 他の言語とは定義が少し違う？
    - deep copy（全プロパティについて、参照先を共有しない完全な複製を作る）はnpmでライブラリが存在する
    
### プロトタイプオブジェクト
- String, Array, Functionなどのほぼすべてのオブジェクトは、`Object.prototype`プロパティに定義された`prototype`オブジェクトを継承している
- プロトタイプメソッド：`toString()`などの、prototypeオブジェクトに組み込まれているメソッド
  - **あらゆるオブジェクト（`Object`のインスタンス）は、生成されたときにprototypeに定義されたプロパティやメソッドを継承する**
  - 空のオブジェクトからもプロトタイプメソッドは呼び出せる
  - 生成されたオブジェクトからprototypeオブジェクトに定義されたメソッドを参照できる仕組みをプロトタイプチェーンと呼ぶ
    - 同名メソッドがプロパティに定義されている場合はそちらが優先
- `in`演算子はプロトタイプオブジェクトまで遡ってプロパティの存在を確かめるが、`hasOwnProperty()`はそのオブジェクト自身のプロパティのみを探す
- `Array`などのオブジェクトも`Array.prototype`を持っており、`Array.prototype`は`Object.prototype`を継承している
### 配列
- JSにおける配列（Array）は可変長（≠Javaの配列）
- オブジェクト同様、存在しないインデックスにアクセスしても例外ではなくundefinedが返される
- 要素がlengthと同じ数含まれた配列を密な配列、そうでないものを疎な配列と呼ぶ
  - 要素がそのインデックスに存在するかどうかを確かめるのは`Object.hasOwnProperty()`を使う
- `typeof`演算子では結果はobjectになるので、判定には`isArray()`を使う
- インデックスの取得
  - `Array.indexOf()`は引数と厳密等価な要素のインデックスを返す
  - オブジェクトは、プロパティが同じでも参照が違えば厳密等価比較はfalseになるので、オブジェクト型の要素を探したい場合は代わりに`Array.findIndex()`を使う
- 要素の取得
  - `Array.find()`はコールバック関数の結果がtrueになる要素を返す
  - `Array.slice()`でPythonチックにインデックスの範囲指定で要素を取得できる
- 要素が含まれているかどうかを表す真偽値の取得
  - `Array.includes()`を使えるが、これも厳密等価比較
  - オブジェクト型の要素を検索する場合は`Array.some()`を使う。コールバック関数の結果がtrueになった時点で`some()`はtrueを返す
- 追加と削除
  - `push()`, `pop()`でstack操作、`unshift()`, `shift()`でqueue操作ができる
  - `concat()`で任意の配列や要素を末尾に結合でき、spread構文をリテラル中に書くことで、任意の位置に既存の配列を展開して新しい配列を生成できる
  - `Array.splice(idx, num)`で任意のインデックス番号以降のn個の要素を削除して詰められる
    - 第三引数に追加する要素を書くことで、削除と追加を同時に行うこともできる
  - `Array.length`プロパティに要素数を代入すると配列がその長さに切り詰められる仕様を使って、要素を削除できる
  - 空の配列を参照変数に代入することで、もとの配列を参照する変数がなくなってGC行きになる
  - `Array.flat()`で多次元配列の次元を削減することができる
- **配列操作は、メソッドが破壊的変更なのか、非破壊的変更なのかを注意**
- 配列の反復処理
  - `Array.forEach()`, `Array.map()`, Array.filter()`, Array.reduce()`がポピュラーで、全て高階関数
    - `forEach()`：コールバック関数の引数には、要素、インデックス、配列全体が渡される。非破壊メソッド
    - `map()`：同上。各イテレーションのコールバック関数の返り値から、新しい配列を生成する非破壊メソッド
    - `filter()`：同上。コールバック関数がtrueを返したイテレーションの要素から、新しい配列を生成する非破壊メソッド
    - `reduce()`：CB関数の引数には、累積値、要素、インデックス、配列全体を渡す。`reduce()`自体の第二引数に累積値の初期値を渡せる。
      - 累積値と各要素を順番にCB関数に渡していき、最終的な累積値を返す？
### 文字列、Unicode
- ほぼ配列の知識とPythonの知識で扱えそう、詳細Skip
- 正規表現オブジェクト：`/\s+/`のように/でパターン文字列を囲む正規表現リテラルで作成できる
  - 正規表現リテラルは、JSのソースコードがロードされた時点でパターンが評価される一方、`RegExp`コンストラクタでオブジェクトを作成すると、そのコンストラクタがプログラム内で実行されるタイミングでパターンが評価される
### ラッパーオブジェクト
- JSではプリミティブ型のデータに対してもプロパティアクセスが可能だが、これが可能なのは、対応するラッパーオブジェクトに都度自動変換されているから
### 関数とスコープ
- 関数定義が行われると、同時にその関数に紐付いたスコープが作成される
- スコープ：他の言語同様、変数や関数を参照できる範囲を定めるもので、スコープ内で定義されたものは基本的にスコープ外からはアクセス不可
- 関数スコープ：関数の仮引数、ローカル変数は関数の外からはアクセスできない
- ブロックスコープ：`{}`で囲まれた範囲も１つのスコープを形成する。for文は各ループごとに新しいブロックスコープを作成する
  - Pythonはifやforのブロックスコープを持たない
- スコープチェーン：スコープはネスト可能で、内側のスコープからは外側のスコープの変数を参照できる
  - 変数隠蔽：shadowingとも。内側のスコープで外側のスコープの変数と同名の変数を定義すると、外側の変数が参照できなくなる（内側の変数が優先される）
- グローバルスコープ：プログラム直下の最も外側のスコープのことで、暗黙的に作成される。ここに定義された変数をグローバル変数と呼び、あらゆるスコープから参照可能
  - ビルトインオブジェクトはグローバルスコープ上に自動で定義されるので、プログラムのどこからでも参照可能
  - 自作のグローバル変数とBIOとの名前衝突を避ける意味でも、無闇なグローバル変数宣言はNG
- `var`によるスコープの巻き上げ
  - 変数の巻き上げ： `var`を使って変数を宣言すると、実際に変数宣言する処理の前にその変数を参照した場合に、`Referrence Error`ではなくundefinedを返す（参照できてしまう）
    - 変数宣言自体は”最も近い関数スコープの先頭”or”グローバルスコープの先頭”で自動的に行われ、値の代入だけが実際にコード上に書かれた部分で行われる、という特殊な挙動が原因
  - さらに、`var`による巻き上げはブロックスコープの存在を無視する
  - `function`による関数宣言も`var`同様スコープの先頭に巻き上げられるが、通常の関数宣言であれば、`var`による変数の初期化とは違って宣言が完了した時点で呼び出し可能になるのであまり問題はない
    - **逆に言えば、関数式を`var`に代入する場合は、関数の呼び出し位置に注意する必要がある**
  - 結論→`var`は使うべきではない
- 即時実行関数：Immediately-Invoked Function Expressionとも
  - ES6以前の、`var`による変数宣言でのグローバルスコープの汚染を避けるために作られたイディオム
  - 匿名関数の宣言をカッコで囲んで関数式として解釈させ、その実行を同時に行うことで、任意の処理をその関数スコープの内側に閉じて実行できる
  - `let`や`const`の宣言はブロックスコープに正しく紐付けられるので、IIFEを使わなくてもブロックスコープ&`let`でグローバル汚染は避けられるようになった
- クロージャー：**関数が、自身の外側のスコープにある変数への参照を保持できる**という性質、またはそのような関数
  - これによって、関数が状態を持っているかのように動作することが可能
  - 静的スコープとGabage Collectionが関係している
    - 静的スコープ（レキシカルスコープ）：どの識別子がどの変数を参照するのかが、実行する前に（処理を定義した段階で）定まっている（静的）というJSの性質
      - 動的スコープ：呼び出し元に応じて、識別子が参照する変数が変わる仕組み（JSは静的）
    - GC：メモリ上のデータが参照されていなければそのメモリを解放する仕組み
      - 関数スコープで定義されたデータも、それが返り値として変数に代入されるなどして参照されていれば、関数の実行が終了してもメモリ解放はされない
  - クロージャーとは、**静的スコープとGCの仕組みを利用して、関数内から特定の変数を参照し続けることで、関数が状態を持つかのように動作できる仕組み**
  - privateな変数を定義する、グローバル汚染をへらす、動的な高階関数を定義するなどの目的で使われる
  - 関数はオブジェクトなので、プロパティで直接状態を持たせることも可能だが、関数外から関数オブジェクトのプロパティを操作できてしまうので非推奨
### 関数と`this`
- `this`：読み取り専用の変数のようなもので、どこで評価するかによって参照する先が変わる特殊なキーワード。基本的にメソッドにおける挙動を覚えておけばOK
- グローバルスコープで評価すると、Scriptモードなら`window`または`global`オブジェクト、Moduleモードなら`undefined`になる
- 関数やメソッドで評価すると、Arrow Functionでの関数定義とそれ以外で結果が変わる
  - Arrow以外だと、`this`は実行時に呼び出し元に応じて動的に定まる
    - Pythonにおける`self`引数の動きのように、その関数が属するベースオブジェクトが暗黙的に入る
    - ベースオブジェクトが無い＝メソッドではない関数の場合は`this`を使う意味はない
  - Arrowで定義された関数やメソッドの`this`の評価結果は、関数定義のときに静的に決定できる
    - 他の場合と異なり、`this`を暗黙の引数として受け取らない
    - Arrow Function内には`this`変数が存在しないとみなされるので、スコープチェーンによって最も近い外側のスコープの`this`を参照する
- `this`が問題になるパターン
  - `this`を含むメソッドを変数に代入した場合、メソッドとそれが属していたオブジェクトが切り離されるので、`this`によるベースオブジェクトの参照が`undefined`になる
    - メソッドを変数に切り出さずにメソッドはメソッドとして呼び出すことを徹底するか、`this`の値を指定して関数を呼べる`call`, `apply`, `bind`などの関数オブジェクトのメソッドを使って実行する
  - メソッドのコールバック関数で`this`を参照する際、コールバック関数は`callBack()`のようにベースオブジェクト無しで呼び出されるので、`this`が`undefined`になる
    - Arrow Functionでは`this`が暗黙的に渡されないので、自身では`this`を持たず、スコープチェーンによって外側のスコープに`this`を探す
      - メソッドのコールバック関数としてArrow Functionを渡せば、コールバック関数ではなく外側のメソッドの`this`を使うので、正しくベースオブジェクトを参照できる
### クラス
- JSのクラスはES6以降では`class`構文で定義され、内部的には関数オブジェクトの一種
  - 慣例的に関数を使って行われていたクラス定義の手順をパターン化した、糖衣構文の一種
  - 関数定義に関数宣言と関数式があるのと同じで、**クラス定義にはクラス宣言文とクラス式がある**
    - クラス式の定義方法は関数式の形と同じ
- クラスは必ず`constructor()`メソッドを持つ（省略した場合も空のコンストラクタが定義される）
  - 定義したクラスは`new`演算子でコンストラクタを呼び出すことでインスタンス化できる
  - コンストラクタの中で呼ばれる`this`は、インスタンス化されるオブジェクトを参照する
- クラスを関数呼び出しすることは出来ない（クラスはnewでインスタンス化すべきもの）
  - ES6以前の実装では、関数を使ってクラスを書くことが有ったが、混同を避けるために`class`構文で統一するべき
- クラスに定義したメソッドは、各インスタンスから共有される**プロトタイプメソッド**と呼ばれる
  - プロトタイプメソッドは各インスタンス間で共有される（同じ関数を参照する）
  - 一方で、コンストラクタの中で`this`に対してメソッドを定義すると、挙動は同じだが別個の関数オブジェクトをインスタンス化の度に定義する
  - プロトタイプメソッドとそうでないインスタンスメソッドのどちらも、クラスのインスタンスから呼び出せる点は同じ
    - メソッドが共有されるか否か、Arrow Functionの使用の可否（thisを静的に定められるか否か）が異なる
  - 同名で上記2種類のメソッドを定義すると、プロトタイプメソッドとインスタンスオブジェクトのメソッド共に定義されるが、後者が優先して呼ばれる仕組み
    - これは**プロトタイプオブジェクト**と**プロトタイプチェーン**の両輪で成り立つ仕組み（後述）
- アクセッサプロパティ：プロパティの参照、代入時に呼び出される特殊なメソッドで、それぞれ`get プロパティ名() {}`, `set プロパティ名() {}`と書くことで定義できる
  - getter, setterを拡張＆明示するためのもの？
  - getterは必ずreturn文で値を返す必要があり、setterは仮引数にそのプロパティに代入される値を取る
  - 標準のECMAScriptではプライベートプロパティは定義できない
- 静的メソッド（クラスメソッド）：クラス内の、インスタンス化せずに利用できるメソッド
  - メソッド定義の前に`static`をつけるだけでOK
  - クラスメソッド内で`this`を使うとそのクラス自身を参照するので、クラスメソッド内でコンストラクタを呼ぶ際は`return new this(args)`という風にも書ける
- プロトタイプオブジェクト：オブジェクトの`prototype`プロパティの中に作成されるオブジェクト
  - JSのクラスも関数オブジェクトなので、`prototype`プロパティに自動的にこれが作成される
  - `class`構文を使ってプロトタイプメソッドの形で定義をすると、そのメソッドはプロトタイプオブジェクトに属する
    - `constructor`メソッドも`prototype`オブジェクトに定義されている
  - 一方、コンストラクタを使ってインスタンスオブジェクトに対してメソッドを定義すると、それはインスタンスオブジェクト自体に属するメソッドになる
    - 両者は異なるメソッドに対して定義されるので、同名でも並存できる
- プロトタイプチェーン
  - 上述の通り、インスタンスオブジェクト自体にはプロトタイプメソッドは定義されていないが、実際にはクラスのプロトタイプメソッドを呼び出すことができる。これはプロトタイプチェーンのおかげ
    - 以下の2つの処理から成り立つ仕組みで、プロトタイプチェーンと呼ぶときは後者の遡って参照する処理を指す
      - インスタンス生成時に、インスタンスの`[[Prototype]]`という特殊な内部プロパティに、プロトタイプオブジェクトの参照を保存する
        - やろうと思えばこの内部プロパティを読み書き可能だが、基本すべきでない
      - インスタンスが自身のプロパティを参照する際に、上記`[[Prototype]]`まで遡って参照する。スコープチェーンと同じような仕組み
- 継承
  - `extends`でSuperClassを指定してクラスを定義できる
  - SubClassのコンストラクタでは、必ず`super()`でSuperClassのコンストラクタの呼び出しが真っ先に行われる
    - `super`キーワード自体は、SuperClassを参照することを意味する
  - 継承でSubClassを定義した場合、SubClassの`[[Prototype]]`にはSuperClassのプロトタイプオブジェクトが格納される
    - プロトタイプチェーンの仕組みでSubClass→SuperClassとプロトタイプオブジェクトを遡れるので、SubClassはSuperClassのプロトタイプメソッドを継承することができると言える
    - `class`ブロック自体も関数オブジェクトなので、`extends`を使うと`[[Prototype]]`に継承元の`class`ブロックが格納される。`static`メソッドもこの仕組によって継承される
### 例外処理
- `try-catch`構文で例外のハンドリングを行う
- `catch`or`finally`のいずれかが存在すれば、もう一方は省略してOK
  - `try-finally`のみを書いた場合は例外が`catch`される場所が無いので、`finally`が実行されたあとに例外が発生する
- `throw`文でエラーオブジェクトを投げる
  - エラーは全て`Error`オブジェクトの拡張系で、`name`と`message`プロパティを持つ
  - スタックトレースは上から下に呼び出し元を辿れる
### 非同期処理
- 同期処理：コードを順番に処理していき、一つの処理が終わるまで次の処理が行われない
  - 無限ループ等による同期的なブロック処理は、JSがブラウザのメインスレッド上で実行されるため好ましくない（ブロック処理が終了するまで、UIの更新などの操作が何もできなくなり、フリーズしたようなUXを与える）
- 非同期処理：基本的にコードを順番に処理するが、非同期処理については、それが終わるのを待たずに次の処理を始める
  - 同時に実行されている複数の処理がある
  - `setTimeOut(cb, delay)`が好例で、delayミリ秒後にCB関数を呼び出すようにタイマーに登録するが、CB関数の実行は非同期で行われるので、この関数の後に書かれている同期処理はCB関数実行より先に行われる
- 非同期処理も多くはメインスレッド（UIスレッド）で行われる。これは後述の並行処理で非同期処理が走るから。
  - 同期ブロック関数と`setTimeOut()`を併用してみると、後者のコールバックは前者のブロックが解除されるまで呼ばれないことがわかる
  - 非同期処理も同期処理の影響を受けており、同じスレッドで実行されていることが分かる
  - **並行処理（Concurrent）**：JSの非同期処理は大半がこれ。1つのスレッドが、各処理を一定の単位ごとに切り替えながら実行すること
    - 1つの処理単位で重たいものがあると他の処理への切替が遅れる
  - **並列処理（Parallel）**：WebWorker APIなどを使えば実装可能。スレッドを分け、排他的に複数の処理を同時に実行すること
- 単純に`try-catch`で囲むだけでは`setTimeOut()`のような非同期処理のエラーはハンドルできない
  - `try`がブロック内で発生した例外をキャッチするための構文である一方、`setTimeOut()`のコールバックが実行されて例外を生じるのは全ての同期処理が終わった後になり、ブロックの範囲外とみなされる
  - 非同期処理に渡すCB関数の中で`try-catch`を書けば例外自体はキャッチできるが、非同期処理の外からは、非同期処理の中で例外が発生しているのかどうかがわからない
  - エラーファーストコールバック：**非同期処理を扱う高階関数における、非同期処理中の例外を扱うための、CB関数の呼び出し方のルール**
    - 非同期処理が失敗した場合は、CB関数の第一引数にエラーオブジェクトを渡して呼び出す
    - 成功の場合は、CB関数の第一引数には`null`を渡し、第二引数以降には成功時の結果を渡して呼び出す
    - 非同期処理の中で起きたエラーを非同期処理の外に伝えるための共通のパターン
    - 他にも、非同期処理が成功した場合に呼ぶCB, 失敗した場合に呼ぶCBの2種類を渡すパターンなどもある
- Promise：非同期処理を抽象化したオブジェクトであり、それを操作する統一的な仕組みのこと
  - エラーファーストコールバックの発展型の、ES6以降に導入されたBIO
- `Promise`を使った非同期処理の流れ
  - `Promise`インスタンスを返す関数を実装
    - `Promise`のコンストラクタは、`executor`（実際に非同期処理を行うCB関数）を受け取る
      - **`executor`には、「CB関数として`resolve`, `reject`を受け取り、非同期処理が成功した場合には`resolve()`を呼び、失敗した場合には`reject()`を呼ぶ」という実装を行う必要がある**
  - `Promise`インスタンスの`then()` メソッドを呼び出し、**`executor`内で`resolve`, `reject`として扱われるCB関数を実際に登録する**
    - `then()`の引数はそれぞれ`onFulfilled`、`onRejected`と呼ばれ、それぞれ成功時・失敗時に呼ばれるCB関数を表す
    - **`executor`（`Promise`のコンストラクタに渡したCB関数）の中で`resolve`に渡した引数は`onFulfilled`に渡され、`reject`に渡した引数は`onRejected`に渡される**
    - `onFulfilled`, `onRejected`共に省略可能
  - 失敗時の処理だけを定義したい場合は、`then()`の代わりに`catch()`を使うことで明示的に`onRejected`のみを登録できる
    - 可読性的には、`then(onFulfilled).catch(onRejected)`と分けて登録するのが良さそう
- `Promise`を使った非同期処理では自動的に例外がキャッチされる
  - `executor`内で例外が発生した`Promise`インスタンスは自動的に`onRejected`を呼んで例外を渡す
- [`Promise`の非同期処理が実際に実行されるタイミングについて](https://stackoverflow.com/questions/42118900/when-is-the-body-of-a-promise-executed)
  - **`Promise`は、そのインスタンスが生成された時点で`executor`を呼び出す**
- `Promise`のインスタンスには内部的に3つの状態が存在する（直接扱うことはできない）
  - Fulfilled：`resolve`したときの状態で、`onFulfilled`が呼ばれる
  - Rejected：`reject`または例外が生じた状態で、`onRejected`が呼ばれる
  - Pending：上2つのいずれでもない状態で、インスタンス作成時の初期状態
  - 一旦FulfilledまたはRejectedになると、それ以降状態は変化しないので、Settledな状態と呼ばれる
  - `then()`で登録したCB関数は、`Promise`の状態が変化したときに1度だけ呼ばれるものなので、`executor`の中で`resolve`の直後に`reject`や2度めの`resolve`を呼んでもその部分は無視される
  - `Promise.resolve()`や`Promise.reject()`で、FulfilledやRejectedに状態がセットされた`Promise`インスタンスを作成可能で、`then()`や`catch()`はこれらに対してもCB関数を登録できる
    - これで登録したCB関数は常に、同期処理が全て終わった後に非同期的に呼ばれる
- Promiseチェーン：ある非同期処理が終わったら次の非同期処理、というように、複数の非同期処理を順番に扱うための方法
  - `then()`や`catch()`が新しい`Promise`インスタンスを返すので、メソッドチェーンで`then()`や`catch()`をつないでいくことができる。これをPromiseチェーンと呼ぶ
  - PromiseがRejectedになったときは、最も近い失敗時の処理（`then()`の第二引数or`catch()`）が呼び出され、その際には間にある成功時の処理はスキップされる
    - RejectedのPromiseに対して`then`->`then`->`catch`と処理をつなげても、実行されるのは`catch`だけ
  - **`then()`,`catch()`が正しく実行された際に返すのはFulfilled状態のインスタンスで、`then()`,`catch()`内で例外が生じた際に返されるのはRejected状態のインスタンス**
  - **Promiseチェーンの`then`,`catch`のコールバック内から`return`で値を返すと、それが次の`then`のコールバックに引数として渡される**
    - CBから値を返すと、その`then`が返すPromiseインスタンスはその返り値を使って`resolve`する
      - つまり、`return new Promise.resolve(returnValue)`のように、その返り値を使ったFulfilledなPromiseインスタンスを返しているので、次の`then`のCBにその値が渡される
    - Promiseインスタンスを返り値として明示的に返す場合は、そのPromiseインスタンスが次の`then`,`catch`にそのまま渡される
      - つまり、FulfilledだけでなくRejectedなPromiseインスタンスをチェーンの中で返すことも可能
- Promiseチェーンの最後に、非同期処理の成功失敗を問わず実行するCB関数を`finally()`で登録できる
- Promiseチェーンで非同期処理をつなげることで、各々の非同期処理を逐次的に実行していくことができる
- `Promise.all()`：複数のPromiseインスタンスを配列として受け取り、それらの全てがFulfilledとなれば、新しくFulfilledなPromiseインスタンスを返し、一つでもRejectedなものがあれば新しくRejectedなインスタンスを返す
  - `then`で登録した`resolve`には、各Promiseの結果を配列にまとめたものが引数に渡される
- `Promise.race()`：複数のPromiseインスタンスを配列として受け取り、その中で1番最初にSettleになったインスタンスと同じ状態の新しいPromiseインスタンスを返す
  - 1番最初に`resolve`された値で新しいインスタンスも`resolve`される
  - 複数の非同期処理を競争させて、一番最初に完了したものに対して次の処理を呼び出すイメージ
  - あるPromiseと、指定時間後に`reject`するPromiseを`race()`でまとめることで、指定時間以内に処理が終わらなければタイムアウト、という処理を実装できる
- Async Function：ES2017以降の、非同期処理を専門とする関数を定義する構文で、**必ずPromiseインスタンスを返す関数**を定義する
  - 値を返した場合、その値で`resolve`したPromiseインスタンスを返す
    - 例えば`async function func() {return resolveValue;}`に書くことで定義可能で、この関数は`new Promise.resolve(resolveValue)`を返す
  - 返り値を指定しなかった場合は`undefined`で`resolve`したPromiseインスタンスを返す
  - Promiseインスタンスを返した場合、そのPromiseインスタンスをそのまま返す
  - 例外が生じた場合、そのエラーを持つRejectedなPromiseインスタンスを返す
  - 関数宣言、関数式、Arrow Function、メソッドのいずれでも定義可能
- `await`式：Async Functionの中でのみ利用できる構文で、右辺のPromiseインスタンスがFulfilled or Rejectedになるまで次の行の処理をストップし（非同期処理の完了を待ち）、インスタンスの状態が変わると処理を再開する
  - 非同期処理を同期処理のように上から下に順番に実行させることができる
  - **`await`は右辺のPromiseインスタンスの評価結果を返り値とする**
    - **PromiseがFulfilledだったら、`resolve`された値が`await`式の返り値になる**
    - PromiseがRejectedだったらその場でエラーを`throw`する
      - Async Function内では例外は自動的にキャッチされてRejectedなPromiseを返す
      - その場でエラーが起きるので、`try-catch`構文でもキャッチできる
  - Promiseチェーンによる逐次的な非同期処理は、`await`式で書き直すほうが圧倒的に可読性が良い
  - `await`を使って非同期処理を一時停止しても、Async Functionの外側の処理は通常通り進む
    - メインスレッドの動作に干渉しないためにAsync Function外では`await`出来ないよう決まっている
    - CB関数の中で`await`を使うためにはCB関数をAsyncにしなければいけないが、CB関数で非同期処理を行っている間にCB関数の外側では処理が進むので、意図しない挙動になることがある
      - `await`を使った反復処理は、CB関数が要求されるArrayのメソッドではなく、forループを使ったほうが楽？
### Map/Set
- ES6以降に導入された、マップ型、セット型のコレクションを扱うためのBIO
- Map：辞書、連想配列、ハッシュマップとも呼ばれるKey：Valueの組み合わせからなるデータ構造
  - JSでは、マップの要素を`[k, v]`という形の配列で表したものをエントリーと呼ぶ。コンストラクタによってMapを初期化する際にはエントリーを渡す
  - 反復処理には`forEach`, `keys`, `values`, `entries`の要素を列挙するメソッドを使う
  - Mapそのものもfor of文で反復可能で、`entries`の返り値を反復するのと同じ結果になる
  - 初期値を持たない`Object`をMapとして転用するケースもある（JSON文字列として使う場合など）
### JSON
- JavaScript Object Notationの通り、JSのオブジェクトリテラルをベースにしているデータ形式
- JSと違い、キーは必ず`""`で囲まなければいけない
- JS上でJSONを扱うにはBIOの`JSON`オブジェクトを使う
  - `JSON.parse()`：JSON形式の文字列をパースして、JS上のオブジェクトとして返す
    - JSONとしてInvalidな文字列をパースすると例外が生じるので、基本的に`try-catch`と併用する
  - `JSON.stringify()`：オブジェクトをJSON文字列に変換して返す
    - サーバーにデータを送信する際などに必要
    - 第二引数はreplacerで、オブジェクトが文字列に変換されるときの挙動をコントロールするための関数、配列を渡す
    - 第三引数はインデント
    - JSONとして表現可能な値しか変換しないので、値がSymbolやundefined、関数オブジェクトなどのプロパティは変換されない（配列の値に含まれる場合はnullに置換される）
    - オブジェクトが`toJSON`メソッドを自前で持っている場合は、文字列変換に優先してそれを使う
### Date
- 日付や時間を扱うBIOだが、機能不十分なので基本的に外部ライブラリと併用するべき
### Math
- 数学的な定数、関数を提供するBIO
- `Math`が提供する定数や関数は全てStaticなもので、`Math`はインスタンスを作らない
- 主なユースケースは擬似乱数生成、最大or最小値取得、小数点以下の処理
### ECMAモジュール
- 1つのJSファイルが1つのモジュールに対応する。以下の理由で活用される
  - 依存性の高いコードを一箇所にまとめそれ以外のモジュールへの依存性を減らすため（保守性）
  - モジュールごとにスコープを分けることで、グローバルの名前空間の汚染を避けるため
  - 使用頻度の高い関数や変数を簡単に再利用可能にするため（再利用性）
- `export`：モジュールの関数や変数を外部のモジュールから参照できるようにする
- `import`：外部のモジュールの関数や変数を、そのモジュールの中で参照する
  - in, exともに名前付き、デフォルトの2種類の手法がある
    - 名前付き：1つのモジュールから複数の関数・変数をエクスポート可能で、オブジェクトの分割代入によって、名前を指定して選択的にインポートできる
      - インポート、エクスポートどちらの際にも`as`を使ってエイリアスを付ける事ができる
    - デフォルト：モジュールごとに一つしかデフォルトエクスポートは出来ない。インポートの際は、デフォルトエクスポートを行っているモジュールを選択して、名前をつけてインポートする
- `import * as`構文を使うと、`as`で宣言した名前空間オブジェクトに、全てのインポートされた要素がプロパティとして格納される
## 2.ハンズオン
### アプリ開発の準備
- Node.js：サーバーサイドでのJavaScript実行環境のひとつで、Chromeと同じv8エンジンで動くクロスプラットフォーム環境
-`npm`：Node Package Managerの略で、node.jsのパッケージ操作を司るコマンドラインツールであり、パッケージがデプロイされるWebサービスも指す
  - `npx`：npmパッケージのインストールと実行をまとめて行うコマンド
    - `npm install <package>`して、インストールしたディレクトリでパッケージを実行するのと同じ
  - npm上には多様なローカルサーバーモジュールが公開されている
### Ajax通信を使ったアプリの開発
- 要件
  - GithubのIDをテキストボックスに入力可能
  - 入力IDをもとにユーザー情報を取得
  - 取得したユーザー情報をアプリ上で表示
- エントリポイント：アプリの一番最初に呼び出される部分で、WebアプリならLPのこと
- HTTP通信の実装
  - Fetch API：HTTP通信を行ってリソースを取得するための標準APIで、XHRの上位互換らしい
    - ページ全体の再読み込みをすることなく、非同期で指定のURLからデータ取得可能（Ajax通信）
    - `fetch`メソッドにURLを与えることでHTTPリクエストが作成、送信される
    - `fetch()`の返り値はPromiseインスタンスで、HTTPレスポンスを表す`Response`オブジェクトを使って`resolve`される（つまり、`then`のCB関数には`Response`オブジェクトが渡される）
    - `Response.json()`の返り値もPromiseで、これはHTTPレスポンスのボディをJSONとしてパースしたオブジェクトを使って`resolve`される（`then`のCB関数にはレスポンスボディを表すJSONが渡される）
  - HTTP通信はエラーが起きやすいので、必ずハンドリング用のコードを併せて書く必要がある
    - `fetch`メソッドはHTTP通信でエラーが生じると、`NetworkError`などでRejectedされたPromiseインスタンスを返す
    - HTTPレスポンスのステータスコードが200なら`Response.ok`がtrueになり、400,500番台ならfalseになる
- APIから取得したデータの表示
  - Fetch APIで取得したレスポンスデータを見やすい形で表示するにはHTML要素として整形する必要がある
  - JSでのHTML文字列の生成には、文字列中の改行や変数埋め込みが可能なテンプレートリテラルを使うのが便利
    - テンプレートリテラルは、関数を使って最終的な評価値を操作でき、これをタグ付けと呼ぶ
    - タグ関数の第一引数はテンプレートリテラルの中の文字列リテラルの配列が入り、第二引数はプレースホルダに挿入される値の配列が入る
  - JS上からHTML文字列をDOMに追加して表示するには、DOM上のデータを挿入したい要素を`document.getElementById()`で取得して、その要素の`innerHTML`プロパティにHTML文字列をセットすることで、その要素の子要素として定義できる
    - `Node.appendChild()`でElementオブジェクトを子要素として追加する方法もある
    - HTMLとして解釈されるべきデータの中に、クオートや不等号などが入っているとHTMLの構造に影響が出るので、`innerHTML`をセットする際はデータをHTMLエスケープ処理する必要がある（大体はライブラリでまかなえる）
- Promiseの活用
  - `main()`関数でfetchUserInfo関数の呼び出しを行い、返り値のPromiseに対して`catch`を書いておくことで、fetchUserInfoのPromiseチェーンの中で発生した例外が`main()`で一元的に処理できる
  - **非同期処理を行う関数は予めPromiseを返すようにしておくと、Async Functionへのリファクタリングが楽になる**
### Node.jsによるCLIアプリ開発
- 要件
  - Markdown→HTMLへの変換
  - コマンドライン引数に変換対象ファイルのパスを受け取る
  - 変換のオプションを引数に与えられる
  - Markdownファイルを読み込み、変換済みのHTMLをSTDOUTに表示する
- Node.jsの概要
  - ブラウザ環境ではconsole.logの出力先はDeveloperToolのコンソールだった一方、Node.js環境でのconsole.logは標準出力に文字列を出力する
  - `$node <jsfile>`と、`node`コマンドに引数としてJSファイルを渡すことで、**Node.js環境でJavaScriptのコードを実行する**ことができる
  - Chromeと同じv8というJavaScriptインタプリタを使っているので、ECMAScriptの基本構文やBIOは同じように使えるが、一部オブジェクトは動きが異なる
    - グローバルオブジェクトが`window`ではなく`global`で、前者に`document`, `XMLHttpRequest`などのプロパティ、関数がある一方で、後者には`process`, `Buffer`などのプロパティ、関数が存在する
      - これらグローバルオブジェクトのプロパティは、いずれの環境でもそのままグローバル変数、関数としてアクセス可能
    - Console APIや`setTimeOut`関数は、ほぼ同等の機能を提供するが、ブラウザとNodeで少しだけ挙動が変わる
- `process`オブジェクトによるコマンドライン引数の取得
  - `process`：Node.jsのグローバルオブジェクトで、現在のNode.jsの実行プロセスについての情報の取得や操作を司るAPIを提供する
    - `process.argv`プロパティで、コマンドライン引数として与えられた文字列の配列にアクセスできる
      - `process.argv`の0番目、1番目はそれぞれ`node`コマンドのバイナリとJSファイルのパスが入るので、ユーザーの打ち込むコマンドライン引数は2番目以降に格納される
      - アプリから扱う場合はライブラリでパースするのが一般的で、今回はcommanderを使う
        - `commander.parse()`でコマンドライン引数をパースすると、`commander.args`プロパティにオプションやフラグを除いたコマンドライン引数のパース結果が格納される
    - `process.exit()`関数で、ステータスを指定してNode.jsの実行プロセスを終了できる
  - `package.json`：アプリの依存するパッケージの、種類やバージョンを記録するファイルで、`package-lock.json`には実際にインストールされたパッケージのバージョンが記録されている
    - `$npm init --yes`でデフォルトの状態でこのファイルが作成され、そこがプロジェクトディレクトリとしてみなされる
    - `devDependencies`：`$npm install --save-dev`でインストールされた開発の際にのみ必要なパッケージ
  - `node_modules` ：`$npm install`されたパッケージが配置されるディレクトリで、インストールされたパッケージは後述の`require`関数で読み込むことでコードの中で使うことができる
  - CommonJSモジュール：ECMAモジュールよりも以前からNode.js環境で利用されているJavaScriptコードのモジュール化の仕組み
    - npmで配布されるパッケージはこの形式でモジュール化されていることがほとんど
    - `module`というNode.jsのグローバル変数を使って変数や関数をエクスポートする
      - `module.export`プロパティに代入されたオブジェクトが、そのファイルからエクスポートされる仕組み
    - グローバル関数`require`を使うことで`module.export`に代入されたオブジェクトをインポートできる
      - `require()`の引数にインポートしたいモジュールのパスを渡すと、返り値としてそのファイルからエクスポートされたオブジェクトが使用可能になる
    - 前述の通りnpmのパッケージもCommonJSモジュールとして配布されており、`node_module`内のインストール済み外部パッケージも`require`関数でインポートできる
- ファイルの読み込み
  - `fs`モジュール：Node.jsの標準モジュールで、ファイルの読み書きを行う関数を提供する
    - 非同期形式、同期形式の関数があり、前者はエラーファーストコールバックの形をとる
      - Node.jsはシングルスレッドなので、他の処理をブロックしにくい非同期形式のAPIが使われることがほとんど
    - `fs.readFile()`でファイルの読み込みを行う
      - CB関数の第一引数には、読み込みが成功すれば`null`, 失敗すればErrorが入り、第二引数には読み込まれたファイルの内容が格納される
        - 非同期処理では単純な`try-catch`では例外がキャッチできないので、エラーファーストコールバックの形式になっている
      - 第二引数のオプションにencodingを渡さないと、バイト列を表す`Buffer`インスタンスの形で読み込みが行われる
- MarkdownをHTMLに変換
  - 変換処理はmarkedパッケージを活用すれば簡単にできる
  - markedをインポートするとMD→HTML変換を行う関数が得られる
    - 変換方法を定めるオプションを与えることも可能
      - gfm(GitHub Flavored Markdown)オプションがデフォルトではtrueになっている
        - 代表的な拡張として、URLが自動的にリンク化される
      - 第二引数にオブジェクトを与えることで変換オプションの有効化、無効化が可能
      - commanderの`option`メソッドを使うことで、コマンドライン引数から受け取れる独自オプションの定義が可能
- ユニットテストの記述
  - ユニットテスト実装のためには、テスト対象のモジュール化が必要（Markdown変換処理をモジュール化）
  - Mocha：JSのテストフレームワーク
    - `it`関数の内部でテストを書き、それがErrorを投げるか否かでテストの成否を判定する
    - `package.json`の`scripts.test`プロパティに`"mocha test/"`と記述することで、`$npm test`を実行すると、`mocha`コマンドで`test/`ディレクトリのテストファイルを実行するように設定できる
    - `test/fixture`にテストで使用する静的ファイルを配置する？
### ToDoWebアプリの開発
- 要件
  - Todoアイテムの追加ができる
  - Todoアイテムの完了状態の更新ができる
  - Todoアイテムの削除ができる
  - Todoアイテムの合計の表示ができる
- エントリポイント実装
  - ECMAモジュールでJSをモジュール化する
    - `<script type="module">`でロードすることでECMAモジュールの機能が使える
    - 分割したものを別々のモジュールとして読み込むと、各JSファイルは固有のモジュールスコープを持つようになり連携ができなくなる
    - 通常は、エントリポイントのHTMLから読み込まれるJSファイルを1つに絞って、そのJSファイルから`import`で他のモジュールを読み込むことでモジュールの連携を実装する
      - JSファイルにおけるエントリポイントを定める
      - **ECMAモジュール利用の際はHTMLから読み込むモジュールは1つで良い**
      - `import`の際は拡張子まで含めたパスが必要
    - HTTPプロトコルでないとCORSが働かないので、Same Origin PolicyによってECMAモジュールへのアクセスがブロックされる→ECMAモジュールを使う際はローカルサーバーが必要
- アプリの構成要素の確認
  - HTTP通信などは使わないので、HTML, CSS, JSのクライアントサイドのみで完結する
- Todoアイテムの追加の実装
  - 以下の操作でアイテムが追加される、という仕様
    - input formにTodoアイテムのタイトルを入力
    - input form上でEnterキーを押してSubmit
    - TodoリストのDivにアイテムの要素が追加される
  - 実現に必要なJSの実装
    - input formから内容の取得
    - form要素のSubmitイベントを監視する
    - 入力値をタイトルとするTodoアイテム要素を作成し、目的のDivに追加する
  - イベントリスナー：イベントが発生した際に呼び出されるCB関数のことで、イベントハンドラーとも呼ばれる
    - `HTMLElement.addEventListener(event, CB(event))`：HTML要素に対して、第一引数のイベントが発生したときに呼ばれるイベントリスナー関数（第二引数のCB）を登録する
    - form-submitイベントはページをリロードするので、`event.preventDefault()`でそのイベントのデフォルトの挙動をOFFにしておく
    - イベントの発生に基づいて処理を進めるようなプログラムを**イベント駆動**と呼ぶ
  - HTML文字列をDOMの要素として加工し、DOM Treeに追加する
    - 既存の要素の中に要素を追加するには、追加したい要素はHTMLの文字列ではなくHTMLElement型である必要がある
    - `template`要素：HTML5以降で使える、HTML形式の文字列からHTML要素を生成できる要素
- イベントとモデル
  - モデル：データを柔軟に扱うための抽象的なレイヤー
    - DOMのイベントに応じて直接DOMの要素を修正するのではなく、ToDoList、ToDoListItemをJSのクラスとしてモデル化して扱うことで以下の問題を解決する
      - DOMを直接更新しているせいで、アイテムの完了状況などの状態に関する情報がDOM上にしか存在しない
      - あるイベントが発生した際に修正すべきDOM要素が拡張に応じて増えていき保守性が下がる
      - 追加されるDOM要素の識別子が無いので、アイテムを個別に扱うことが出来ない
    - フォームを送信すると`TodoListModel`に`TodoItemModel`が追加され、それに応じて`TodoListModel`がイベントをディスパッチし、自身に登録されたリスナー関数を使ってDOMを更新する、という流れ
  - イベントのディスパッチ（発生）
    - イベント駆動の仕組みは、イベントのディスパッチャとイベントのリスナーという2つの主体から成り立ち、ディスパッチャがリスナーを兼ねる（自分自身で発生させたイベントを自分でリッスンする）こともある
    - Observerパターンの実装
      - ディスパッチャ、リスナーの機能を併せ持つSuperClassを定義して、ToDoListModelにそれを継承させる
        - TodoListModelは配列型のプロパティとして、複数のTodoItemModelを保持する
        - TodoListModelは自身の状態が変化した時、changeイベントを自身に対してディスパッチする
        - TodoListModelは`addEventListener`を持ち、changeイベントに応じて呼ばれるリスナー関数を保持する
      - SuperClassは、`emit()`で指定したイベントに登録されている全てのCB関数を呼び出し、`addEventListener()`で指定したイベントに任意のCB関数を登録できる
- アイテムの更新と削除の実装
  - `<input type="checkbox">`は`checked`属性の有無でボックスにチェックが入っているか否かを表現する
    - チェックボックスの状態をモデルの状態に反映するには、`input`要素がディスパッチするイベントをリッスンする必要がある
- リファクタリング
  - メインのJSファイル（App.js）の処理の殆どがHTML要素の処理であり、肥大化したファイルからHTML処理を切り分ける
    - 表示用のHTML要素の処理を行っている部分をViewコンポーネントとして切り出す
  - アプリのライフサイクル：load, unloadに応じてイベントのAdd, Removeを行ってメモリを解放する処理を意識する
### Appendix
- トランスパイラ：ソースコードを他のソースコードに変換するもの
  - Babel：ES6以降のコードをES5に変換（IE対応、ECMAの最新アップデートのテストなどに使われる）
  - TypeScript：静的型付けの構文を追加した言語兼トランスパイラ
- モジュールバンドラー：モジュール依存関係の解決を行い、複数のモジュールを1つのJSファイルに結合するツール
  - npm上で配布されるCommonJSモジュールを、Node.js環境のみならずブラウザ環境でも動かすためにこうしたツールが使われる
  - webpack：CommonJSモジュール、ECMAモジュールの依存関係を解決する上、画像、CSSなどの静的リソースを読み込むための仕組みも準備されている
- FaaS（Function as a Service）：クラウド上のNode.jsサーバーのようなもので、デベロッパーがNodeサーバーを用意しなくても、関数単位でNode.jsのスクリプトを実行できるプラットフォーム
  - AWS Lambda
  - Google Cloud Functions
